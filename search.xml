<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>学习git的叙述（长期更新）</title>
    <url>/2023/08/22/%E5%AD%A6%E4%B9%A0git%E7%9A%84%E5%8F%99%E8%BF%B0/</url>
    <content><![CDATA[<h1 id="前言说明"><a href="#前言说明" class="headerlink" title="前言说明"></a>前言说明</h1><p>根据以下资料自学，</p>
<ul>
<li><a href="https://backlog.com/git-tutorial/cn/">猴子都能懂的Git入门</a>（完成）</li>
<li><a href="https://learngitbranching.js.org/?locale=zh_CN">Learning Git Branching 在线游戏</a>(在玩)</li>
<li><a href="https://docs.github.com/zh/get-started">GitHub 入门文档</a>（待学）</li>
<li><a href="https://github.phodal.com/#/">GitHub 漫游指南</a>（待学）</li>
<li><a href="https://oschina.gitee.io/opensource-guide/">开源指北</a>（待学）</li>
<li><a href="https://git-scm.com/book/zh/v2">Git官方文档</a>（待学）</li>
<li><a href="https://docs.github.com/zh">GitHub官方文档</a>（待学）<span id="more"></span></li>
</ul>
<h1 id="内容叙述–猴子都能懂的Git入门（已完结）"><a href="#内容叙述–猴子都能懂的Git入门（已完结）" class="headerlink" title="内容叙述–猴子都能懂的Git入门（已完结）"></a>内容叙述–猴子都能懂的Git入门（已完结）</h1><h2 id="首先"><a href="#首先" class="headerlink" title="首先"></a>首先</h2><p>Git是一个分布式版本管理系统，是为了更好地管理Linux内核开发而创立的。<br>用Git管理文件，更新的历史会保存在Git。<br>如果和别人共享文件修改时有冲突，会发出报错警告。  </p>
<h2 id="Git的数据库"><a href="#Git的数据库" class="headerlink" title="Git的数据库"></a>Git的数据库</h2><p>数据库 (Repository) 是记录文件或目录状态的地方，存储着内容修改的历史记录。<br>Git的数据库分为远程数据库和本地数据库的两种。<br>远程数据库和本地数据库的交流为pull和push。<br>其中：创建本地数据库的方法有两种：一种是创建全新的数据库，另一种是复制远程数据库。<br>提交到远程数据库为了方便协同合作，务必输入准确简洁的提交信息，遵循下列Git的标准注解原则：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">第1行：提交修改内容的摘要</span><br><span class="line">第2行：空行</span><br><span class="line">第3行以后：修改的理由</span><br></pre></td></tr></table></figure>

<h2 id="工作树和索引"><a href="#工作树和索引" class="headerlink" title="工作树和索引"></a>工作树和索引</h2><p>在Git管理下，大家实际操作的目录被称为工作树。<br>在数据库和工作树之间有索引，索引是为了向数据库提交作准备的区域。<br>凭借中间的索引，可以避免工作树中不必要的文件提交，还可以将文件修改内容的一部分加入索引区域并提交。</p>
<h2 id="实操的提前准备"><a href="#实操的提前准备" class="headerlink" title="实操的提前准备"></a>实操的提前准备</h2><p>首先安装<a href="http://msysgit.github.io/">git</a>，再安装开放源代码的Git客户端<a href="http://code.google.com/p/tortoisegit/">TortoiseGit</a>（有官方汉化语言包）。</p>
<h2 id="版本库，工作树，暂存区"><a href="#版本库，工作树，暂存区" class="headerlink" title="版本库，工作树，暂存区"></a>版本库，工作树，暂存区</h2><p>版本库（Repository）： 在Git中，版本库是存储代码历史记录的地方。它包括了整个项目的历史状态、分支、标签等信息。当你执行git init命令创建一个新的版本库时，Git会在你的项目文件夹中生成一个名为.git的隐藏文件夹，这个文件夹就是版本库。</p>
<p>工作树（Working Tree）： 工作树是你项目文件夹中的实际文件和文件夹，它反映了你当前的工作状态。在工作树中进行的文件修改、添加、删除等操作都会被记录下来，然后可以通过提交到版本库来保留这些修改。</p>
<p>暂存区（Staging Area）： 暂存区是位于版本库和工作树之间的一个缓冲区域。当你使用git add命令将文件添加到暂存区时，你正在告诉Git这些文件将会被包含在下一次的提交中。</p>
<p>在操作过程中，文件会从工作树添加到暂存区，然后再从暂存区提交到版本库中。这种分层结构使得Git能够记录代码的变更历史并支持版本控制。</p>
<h2 id="解决冲突"><a href="#解决冲突" class="headerlink" title="解决冲突"></a>解决冲突</h2><p>当前一个数据和后一个数据冲突，需要对手动来解决冲突，我们首先需要pull，得到远程别人最新的修改版本，到本地来对照自己的版本，解决冲突之后再上传push。</p>
<h2 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h2><p>分支是为了将修改记录的整体流程分叉保存。分叉后的分支不受其他分支的影响，所以在同一个数据库里可以同时进行多个修改。<br>为了不受其他开发人员的影响，您可以在主分支上建立自己专用的分支。完成工作后，将自己分支上的修改合并到主分支。因为每一次提交的历史记录都会被保存，所以当发生问题时，定位和修改造成问题的提交就容易多了。</p>
<h3 id="常见的两种分支形式"><a href="#常见的两种分支形式" class="headerlink" title="常见的两种分支形式"></a>常见的两种分支形式</h3><p>Merge分支是为了可以随时发布release而创建的分支，它还能作为Topic分支的源分支使用。保持分支稳定的状态是很重要的。通常，大家会将master分支当作Merge分支使用。</p>
<p>Topic分支是为了开发新功能或修复Bug等任务而建立的分支。若要同时进行多个的任务，请创建多个的Topic分支。Topic分支是从稳定的Merge分支创建的。完成作业后，要把Topic分支合并回Merge分支。</p>
<h3 id="分支的切换"><a href="#分支的切换" class="headerlink" title="分支的切换"></a>分支的切换</h3><p>若要切换作业的分支，就要进行checkout操作。进行checkout时，git会从工作树还原向目标分支提交的修改内容。checkout之后的提交记录将被追加到目标分支。<br>这里需要注意的是，还原的是git本地的，工作区和暂存区，还原之后，就会把版本库和工作树切换到全新的分支。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git checkout -b branchB #-b的参数是branch的意思</span><br><span class="line">git checkout branchB #这里是切换到branchB，如果没有需要加-b参数，切换并创建</span><br></pre></td></tr></table></figure>

<h3 id="head指针"><a href="#head指针" class="headerlink" title="head指针"></a>head指针</h3><p>涉及到分支的切换，就需要了解head的指针，HEAD指向的是现在使用中的分支的最后一次更新。通常默认指向master分支的最后一次更新。通过移动HEAD，就可以变更使用的分支。</p>
<blockquote>
<p>举一个例子：<br>假设你有一个提交历史记录 A -&gt; B -&gt; C -&gt; D -&gt; E，并且”HEAD” 当前指向 E。</p>
</blockquote>
<blockquote>
<p>如果你想要创建一个新的分支 B2，可以使用 git checkout -b B2 命令。这会在 E 的位置创建一个新分支 B2，然后将”HEAD” 移动到 B2，意味着你在 B2 分支上开始了新的工作。</p>
</blockquote>
<blockquote>
<p>如果你想要将版本回退到 C，你可以使用 git reset –hard C 命令。这将会让”HEAD” 和当前分支都指向 C，你的工作树和暂存区也会被还原为 C 的状态。</p>
</blockquote>
<blockquote>
<p>通过切换分支或回退版本，”HEAD” 会移动到不同的提交位置，指向不同的分支或提交。</p>
</blockquote>
<h3 id="stash操作"><a href="#stash操作" class="headerlink" title="stash操作"></a>stash操作</h3><p>还未提交的修改内容以及新添加的文件，留在索引区域或工作树的情况下切换到其他的分支时，修改内容会从原来的分支移动到目标分支。<br>但是如果在checkout的目标分支中相同的文件也有修改，checkout会失败的。这时要么先提交修改内容，要么用stash暂时保存修改内容后再checkout。<br>stash是临时保存文件修改内容的区域。stash可以暂时保存工作树和索引里还没提交的修改内容，您可以事后再取出暂存的修改，应用到原先的分支或其他的分支上。<br>总结：”stash” 在Git中指的是暂时隐藏未提交修改的操作，使你可以在不提交修改的情况下进行其他操作。</p>
<h2 id="分支的合并"><a href="#分支的合并" class="headerlink" title="分支的合并"></a>分支的合并</h2><p>合并分支有2种方法：使用merge或rebase</p>
<h3 id="merge"><a href="#merge" class="headerlink" title="merge"></a>merge</h3><p>merge合并是将一个分支的更改合并到另一个分支的常见方法。合并创建一个新的提交，将两个分支的更改整合到一起。合并提交将会有多个父提交，分别来自于要合并的两个分支。这种方法适用于保留分支历史，使每个分支的更改都能够清楚地追踪。</p>
<h3 id="rebase"><a href="#rebase" class="headerlink" title="rebase"></a>rebase</h3><p>Rebase变基是另一种将分支更改整合的方法，它的目标是创建一个线性的提交历史，使分支看起来像是连续的。在变基过程中，你从一个分支 “复制” 更改，然后将它们 “粘贴” 到另一个分支的末尾。这使得提交历史看起来更干净，但也可能会改变提交的顺序和提交的 SHA 标识。</p>
<p>总结区别：<br>Merge 会创建一个合并提交，它反映了分支间的合并。<br>Rebase 会将源分支的更改逐个应用到目标分支的末尾，形成一个线性的提交历史。</p>
<h3 id="git分支的应用"><a href="#git分支的应用" class="headerlink" title="git分支的应用"></a>git分支的应用</h3><p>点击查看Vincent Driessen大佬的博文<a href="http://nvie.com/posts/a-successful-git-branching-model/">A successful Git branching model</a><br>阅读原文推荐浏览器插件沙拉查词，或则使用欧路词典eudic。<br>作者在时间的推移当中，划分了五个不同类型的branch。<br>类型1：master，主类型，起label的作用，确定档号，最稳定版。    </p>
<blockquote>
<p>作者原话摘抄：We consider origin&#x2F;master to be the main branch where the source code of HEAD always reflects a production-ready state.  </p>
</blockquote>
<p>类型2：hotfixes，紧急类型，起熬夜加班修bug类型,修完之后需要立刻更新到其他develop和master分支上。   </p>
<blockquote>
<p>Hotfix branches are very much like release branches in that they are also meant to prepare for a new production release, albeit unplanned. They arise from the necessity to act immediately upon an undesired state of a live production version. When a critical bug in a production version must be resolved immediately, a hotfix branch may be branched off from the corresponding tag on the master branch that marks the production version.</p>
</blockquote>
<blockquote>
<p>The one exception to the rule here is that, when a release branch currently exists, the hotfix changes need to be merged into that release branch, instead of develop. Back-merging the bugfix into the release branch will eventually result in the bugfix being merged into develop too, when the release branch is finished. (If work in develop immediately requires this bugfix and cannot wait for the release branch to be finished, you may safely merge the bugfix into develop now already as well.)</p>
</blockquote>
<p>类型3：release branches，主要发行版，大部分人使用。<br>类型4：develop ，主要开发者版本，开发者使用通行版，最终要回归master。   </p>
<blockquote>
<p>作者原话摘抄：We consider origin&#x2F;develop to be the main branch where the source code of HEAD always reflects a state with the latest delivered development changes for the next release. Some would call this the “integration branch”. This is where any automatic nightly builds are built from.  </p>
</blockquote>
<p>类型5：feature branches，特性开发版本，这里可以允许开发者扩展多个分支，同时开发多种特性。    </p>
<blockquote>
<p>作者原话摘抄：Feature branches (or sometimes called topic branches) are used to develop new features for the upcoming or a distant future release. When starting development of a feature, the target release in which this feature will be incorporated may well be unknown at that point. The essence of a feature branch is that it exists as long as the feature is in development, but will eventually be merged back into develop (to definitely add the new feature to the upcoming release) or discarded (in case of a disappointing experiment).</p>
</blockquote>
<p>细节方面：<br>在某一个feature branch开发完成后，需要这样回归</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git chekout feature </span><br><span class="line">#Switched to branch &#x27;develop&#x27;</span><br><span class="line">git merge --no-ff myfeature </span><br><span class="line">#Updating ea1b82a..05e9557</span><br><span class="line">git branch -d myfeature </span><br><span class="line">#Deleted branch myfeature (was 05e9557).</span><br><span class="line">git push origin develop </span><br><span class="line">#从本地上传</span><br></pre></td></tr></table></figure>
<p>这里的合并使用了 git merge –no–ff myfeature，是为了避免fast-forward合并对合并的影响，是为了保留已经合并的myfeature记录。</p>
<h2 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h2><p>标签是为了更方便地参考提交而给它标上易懂的名称。<br>Git可以使用2种标签：轻标签和注解标签。打上的标签是固定的，不能像分支那样可以移动位置。</p>
<p>轻标签格式</p>
<ul>
<li>添加名称</li>
</ul>
<p>注解标签格式</p>
<ul>
<li>添加名称</li>
<li>添加注解</li>
<li>添加签名</li>
</ul>
<h2 id="改写提交"><a href="#改写提交" class="headerlink" title="改写提交"></a>改写提交</h2><p>改写提交是指对已经提交的提交记录进行修改或修正。在Git中，这通常用于更正提交信息、合并提交、重新排序提交或重新整理提交历史。</p>
<p>以下是一些常见的改写提交的操作：</p>
<ul>
<li>修改提交信息:你可以使用git commit –amend 命令来修改最新的提交信息。这会打开文本编辑器，允许你修改提交的注释。这在提交信息拼写错误或需要补充信息时很有用。</li>
<li>合并提交： 如果你发现你在之前的几次提交中有类似的修改，你可以使用交互式 rebase（git rebase -i）来合并这些提交，将它们合并成一个更大的提交。</li>
<li>重新排序提交： 使用交互式 rebase，你可以重新排序提交历史，改变提交的顺序。</li>
<li>删除提交： 使用交互式 rebase 或 git reset 命令，你可以删除不需要的提交。但要注意，删除已经被推送到远程仓库的提交可能会引起问题。</li>
<li>拆分提交： 通过交互式 rebase，你可以将一个大的提交拆分成多个较小的提交，从而更好地划分功能或修改。</li>
<li>修改文件内容： 如果你希望修改之前提交中的文件内容，你可以使用 git commit –amend 进行提交，并在其中修改文件内容。但要注意，修改已经被推送到远程仓库的提交可能会影响其他人。</li>
</ul>
<p>常见的改写命令：</p>
<ul>
<li>commit –amend  #修改最近一次的提交注释</li>
<li>revert  #用revert命令来取消提交</li>
<li>reset –hard HEAD~  #向后移动HEAD指针</li>
<li>cherry-pick +哈希值  #从分支当中根据哈希值来融进主支</li>
<li>用rebase -i 汇合提交  #合并两次提交，需要squash</li>
<li>用rebase -i 修改提交  #进行修改提交，需要edit</li>
<li>merge –squash  #把分支合并提交<br>其中reset当中的参数<br>模式名称	HEAD的位置	  索引	 工作树   主要使用场合<br>soft		修改		不修改	不修改   只取消提交<br>mixed		修改		修改	不修改   复原修改过的索引的状态<br>hard		修改		修改	修改     彻底取消最近的提交</li>
</ul>
<h1 id="内容叙述–Learning-Git-Branching-在线游戏（在玩）"><a href="#内容叙述–Learning-Git-Branching-在线游戏（在玩）" class="headerlink" title="内容叙述–Learning Git Branching 在线游戏（在玩）"></a>内容叙述–Learning Git Branching 在线游戏（在玩）</h1>]]></content>
      <categories>
        <category>编程学习笔记</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
</search>
