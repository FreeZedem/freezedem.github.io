<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Java多线程与反射</title>
    <url>/2023/10/11/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%8F%8D%E5%B0%84/</url>
    <content><![CDATA[<h1 id="多线程与反射"><a href="#多线程与反射" class="headerlink" title="多线程与反射"></a>多线程与反射</h1><h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><h3 id="线程的创建和启动"><a href="#线程的创建和启动" class="headerlink" title="线程的创建和启动"></a>线程的创建和启动</h3><p>说起多线程就要说起进程和线程的概念，每一次运行程序，进程就会出现，线程是进程的一部分。</p>
<p>进程是操作系统分配资源的基本单位，进程是程序执行的实体，每一个进程都是一个应用程序，进程是拥有资源和独立运行的最小单位，也是程序执行的最小单位。</p>
<p>需要多线程技术，就是为了避免多进程的之间通信的问题，多线程在一个进程内享有资源共读上下文，比额外访问另外一个进程要好太多了。</p>
<span id="more"></span>
<p><strong>一个进程可以有多个线程，线程是程序执行中一个单一的顺序控制流程，现在线程才是程序执行流的最小单元，各个线程之间共享程序的内存空间（也就是所在进程的内存空间），上下文切换速度也高于进程。</strong></p>
<p>下面是一个多线程，同时执行的例子，使用的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">            System.*out*.println(<span class="string">&quot;我是线程1&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">            System.*out*.println(<span class="string">&quot;我是线程2&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>把线程的观念，带入编程当中，那么main就是一个进程的主线程。</p>
<p>如果我们额外new 一个全新的线程，那么它是从主线程当中分支出来一起执行的一个个线程，是一次归属于同一个进程。</p>
<p>在Java当中线程有五个状态，新建（new），就绪&#x2F;可运行（runnable），运行中（running），休眠（Blocked&#x2F;Sleeping），终止（Terminated）。</p>
<p>我们调用start方法并不代表立刻马上的进入运行状态，你也需要看底层的硬件是不是允许的，它会进入Runnable状态，等待CPU调用完毕别的，来进入Running状态。</p>
<p>如果我们遇到类似与Scanner这种需要交互的输入流时，当前线程往往会休眠，CPU去干别的事情去了。</p>
<p>当我们程序的线程跑完的时候，程序运行到结束，或则出现了意外，报错或则是异常，线程就会终止。</p>
<h3 id="线程的休眠和中断"><a href="#线程的休眠和中断" class="headerlink" title="线程的休眠和中断"></a>线程的休眠和中断</h3><p>在休眠和中断当中，很明显的体现了一个具体的框架，就是</p>
<p>New-&gt;Runnable-&gt;Running-&gt;Blocked&#x2F;Sleep-&gt;Running-&gt;Blocked&#x2F;Sleep-&gt;Running-&gt;Blocked&#x2F;Sleep-&gt;…..-&gt;Running-&gt;Terminated。</p>
<p>具体的程序例子如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    System.*out*.println(Thread.*currentThread*().getName()+<span class="string">&quot;线程启动&quot;</span>);</span><br><span class="line">    System.*out*.println(<span class="string">&quot;T&quot;</span>);</span><br><span class="line">    Thread.*sleep*(<span class="number">1000</span>);</span><br><span class="line">    System.*out*.println(<span class="string">&quot;E&quot;</span>);</span><br><span class="line">    Thread.*sleep*(<span class="number">1000</span>);</span><br><span class="line">    System.*out*.println(<span class="string">&quot;M&quot;</span>);</span><br><span class="line">    Thread.*sleep*(<span class="number">1000</span>);</span><br><span class="line">    System.*out*.println(<span class="string">&quot;P&quot;</span>);</span><br><span class="line">    Thread.*sleep*(<span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>值得一提的是，使用stop()（已经被java建议废止）会强行中止，这里会出现一个问题，打个比喻，你公司停电，你代码没保存和公司停电前有通知，让你保存完代码再下班，这就是InterruptedException异常的作用，用来捕捉打了Interrupted标记的线程，并让其下线。</p>
<p>下面是示例代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName());</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span> (Thread.currentThread().isInterrupted())&#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;我被中断了，切换到下一个循环&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            Thread.interrupted();<span class="comment">//让Interrupted 复原成为原来的false。</span></span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span> (Thread.currentThread().isInterrupted())&#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;我被中断了&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;线程结束&quot;</span>);</span><br><span class="line">        &#125;,<span class="string">&quot;我是Interrupted检测线程&quot;</span>);</span><br><span class="line">        thread1.start();</span><br><span class="line">        System.out.println(Thread.currentThread().getName());</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        thread1.interrupt();</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        thread1.interrupt();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>下面是使用Thread当中的resume()恢复线程方法和suspend()悬挂线程的方法。（这两个方法已经被java所弃用，这里使用来做演示）</p>
<p>下面是示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">       <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">           System.out.println(<span class="string">&quot;我停止了&quot;</span>);</span><br><span class="line">           Thread.currentThread().suspend();</span><br><span class="line">           System.out.println(<span class="string">&quot;我被线程2恢复了&quot;</span>);</span><br><span class="line">       &#125;);</span><br><span class="line">       <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">           &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">           &#125;</span><br><span class="line">           System.out.println(<span class="string">&quot;恢复线程1&quot;</span>);</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">           &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">           &#125;</span><br><span class="line">           thread1.resume();</span><br><span class="line">       &#125;);</span><br><span class="line">       thread1.start();</span><br><span class="line">       thread2.start();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="线程的优先级"><a href="#线程的优先级" class="headerlink" title="线程的优先级"></a>线程的优先级</h3><p>Java采用的是抢占式调度方式，优先级越高的线程，优先使用CPU资源。指的主要就是setPriority方法。</p>
<p>具体效果如下图所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">       <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">           System.out.println(Thread.currentThread().getName());</span><br><span class="line">       &#125;);</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * The minimum priority that a thread can have.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">//public final static int MIN_PRIORITY = 1;</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * The default priority that is assigned to a thread.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">//public final static int NORM_PRIORITY = 5;</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * The maximum priority that a thread can have.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">//public final static int MAX_PRIORITY = 10;</span></span><br><span class="line">       thread.setPriority(<span class="number">3</span>);</span><br><span class="line">       thread.start();</span><br><span class="line">    &#125;		</span><br></pre></td></tr></table></figure>

<p>设置的优先级越大，获得的cpu使用的概率越大，不一定是100%有效的必须。</p>
<h3 id="线程的礼让和加入"><a href="#线程的礼让和加入" class="headerlink" title="线程的礼让和加入"></a>线程的礼让和加入</h3><p>线程的礼让主要是调用Thread.yield()方法，让别的线程优先执行。</p>
<p>具体示例如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>  &#123;</span><br><span class="line">       <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt;&#123;</span><br><span class="line">           <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line">               System.out.println(Thread.currentThread().getName()+<span class="string">&quot;:&quot;</span>+i);</span><br><span class="line">               <span class="keyword">if</span> (i%<span class="number">5</span>==<span class="number">0</span> &amp;&amp; i!=<span class="number">0</span>)&#123;</span><br><span class="line">                   System.out.println(<span class="string">&quot;5的倍数，开始让别的线程执行&quot;</span>);</span><br><span class="line">                   Thread.<span class="keyword">yield</span>();</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;,<span class="string">&quot;thread1&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot;:&quot;</span>+i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;thread2&quot;</span>);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>而线程的加入主要是线程的join()方法，可以在别的线程当中，呼唤别的线程来优先完成，在回到本线程再执行。</p>
<p>下面是具体的示例代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>  &#123;</span><br><span class="line">   <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt;&#123;</span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= <span class="number">50</span>; i++) &#123;</span><br><span class="line">           System.out.println(Thread.currentThread().getName()+<span class="string">&quot;:&quot;</span>+i);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;,<span class="string">&quot;thread1&quot;</span>);</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt;&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= <span class="number">50</span>; i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;:&quot;</span>+i);</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">10</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(thread1.getName()+<span class="string">&quot;  join in &quot;</span>+Thread.currentThread().getName());</span><br><span class="line">                    thread1.join();</span><br><span class="line">                    System.out.println(thread1.getName()+<span class="string">&quot;is over&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,<span class="string">&quot;thread2&quot;</span>);</span><br><span class="line">    thread1.start();</span><br><span class="line">    thread2.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="线程锁和线程同步"><a href="#线程锁和线程同步" class="headerlink" title="线程锁和线程同步"></a>线程锁和线程同步</h3><p>首先来看Java多线程下的内存管理。</p>
<p>主内存&lt;-&gt;Save&#x2F;Load&lt;-&gt;工作内存&lt;-&gt;Java线程</p>
<p>​								  &lt;-&gt;工作内存&lt;-&gt;Java线程</p>
<p>​								  &lt;-&gt;工作内存&lt;-&gt;Java线程</p>
<p>​									…………………………….</p>
<p>多线程因为共用变量，Java线程操作的是从工作内存copy的副本，完成操作之后再写入主内存，就这样不断的读写读写。</p>
<p>如果在同一个时间的切片当中，有两个及其以上的线程，同时操作工作内存，给主内存上传下载，会出现问题。</p>
<p>具体代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="comment">//一边执行内存读操作和写操作</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) value++;</span><br><span class="line">        System.out.println(<span class="string">&quot;线程1完成&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="comment">//一边执行内存读操作和写操作</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) value++;</span><br><span class="line">        System.out.println(<span class="string">&quot;线程2完成&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    t1.start();</span><br><span class="line">    t2.start();</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);  <span class="comment">//主线程停止1秒，保证两个线程执行完成</span></span><br><span class="line">    System.out.println(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那为了解决这种多线程的问题，我们就需要加个锁来维持秩序。</p>
<p>这里使用的是悲观锁synchronized，使用的是一个Object的对象来当锁。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">o1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();<span class="comment">//对象锁，同一个对象多个线程才生效</span></span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="comment">//一边执行内存读操作和写操作</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++)</span><br><span class="line">                <span class="comment">//悲观锁synchronized</span></span><br><span class="line">                <span class="keyword">synchronized</span> (o1)&#123;</span><br><span class="line">                value++;</span><br><span class="line">                &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;线程1完成&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++)</span><br><span class="line">                <span class="comment">//同步代码块，对象锁</span></span><br><span class="line">                <span class="keyword">synchronized</span> (o1)&#123;</span><br><span class="line">                value++;</span><br><span class="line">                &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;线程2完成&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);  <span class="comment">//主线程停止1秒，保证两个线程执行完成</span></span><br><span class="line">        System.out.println(value);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>同样的为了解决多线程的冲突问题，也可以使用悲观锁synchroized来修饰方法名，来达到同样的效果。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">   <span class="comment">//使用悲观锁，所有多线程，同一时刻，只有一个线程使用。</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">()</span>&#123;</span><br><span class="line">       value++;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">       <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">           <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++)</span><br><span class="line">               add();</span><br><span class="line">           System.out.println(<span class="string">&quot;线程1完成&quot;</span>);</span><br><span class="line">       &#125;);</span><br><span class="line">       <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">           <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++)</span><br><span class="line">               add();</span><br><span class="line">           System.out.println(<span class="string">&quot;线程2完成&quot;</span>);</span><br><span class="line">       &#125;);</span><br><span class="line">       t1.start();</span><br><span class="line">       t2.start();</span><br><span class="line">       Thread.sleep(<span class="number">1000</span>);  <span class="comment">//主线程停止1秒，保证两个线程执行完成</span></span><br><span class="line">       System.out.println(value);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>它和原先的代码块当中的关系是调动类锁，如下图所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="comment">//使用悲观锁，所有多线程，同一时刻，只有一个线程使用。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">()</span>&#123;</span><br><span class="line">    value++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++)</span><br><span class="line">            add();</span><br><span class="line">        System.out.println(<span class="string">&quot;线程1完成&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++)</span><br><span class="line">            <span class="comment">//因为static方法所以调用Main.class类本身来锁。</span></span><br><span class="line">            <span class="comment">//如果是new一个对象的话，就是调用this对象本身的变量来锁。</span></span><br><span class="line">            <span class="comment">//可以看到下面的结果是等价的。</span></span><br><span class="line">            <span class="keyword">synchronized</span> (Main.class)&#123;</span><br><span class="line">            value++;</span><br><span class="line">            &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;线程2完成&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    t1.start();</span><br><span class="line">    t2.start();</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);  <span class="comment">//主线程停止1秒，保证两个线程执行完成</span></span><br><span class="line">    System.out.println(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p>死锁的概念在操作系统中也有提及，它是指两个线程相互持有对方需要的锁，但是又迟迟不释放，导致程序卡住。</p>
<p>下面是对一个概念的具体描述：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>  &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">o1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();<span class="comment">//创造锁o1</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">o2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();<span class="comment">//创造锁o2</span></span><br><span class="line">        <span class="comment">//两个线程互相持有对方的锁，导致死锁的状态发生。</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (o1)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//等待1秒，确保程序能够同时跑完</span></span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                    System.out.println(<span class="string">&quot;我已经等待1秒了&quot;</span>+Thread.currentThread().getName());</span><br><span class="line">                    <span class="keyword">synchronized</span> (o2)&#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;线程1&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (o2)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//等待1秒，确保程序能够同时跑完</span></span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                    System.out.println(<span class="string">&quot;我已经等待1秒了&quot;</span>+Thread.currentThread().getName());</span><br><span class="line">                    <span class="keyword">synchronized</span> (o1)&#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;线程2&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>所以，我们在编写程序时，一定要注意，不要出现这种死锁的情况。那么我们如何去检测死锁呢？我们可以利用jstack命令来检测死锁，首先利用jps找到我们的java进程，然后再使用jstack +java进程id去检测有无死锁。</p>
<p>或则使用jconsole可视化也可以进行监测</p>
<p>因此，前面说不推荐使用 <code>suspend()</code>去挂起线程的原因，是因为<code>suspend()</code>在使线程暂停的同时，并不会去释放任何锁资源。其他线程都无法访问被它占用的锁。直到对应的线程执行<code>resume()</code>方法后，被挂起的线程才能继续，从而其它被阻塞在这个锁的线程才可以继续执行。但是，如果<code>resume()</code>操作出现在<code>suspend()</code>之前执行，那么线程将一直处于挂起状态，同时一直占用锁，这就产生了死锁。</p>
<h3 id="wait和notify方法"><a href="#wait和notify方法" class="headerlink" title="wait和notify方法"></a>wait和notify方法</h3><p><code>wait()</code>、<code>notify()</code>以及<code>notifyAll()</code>这些Object最基础的方法之一，需要配合同步代码块synchronized来使用，实际上锁是依附于对象存在的，每个对象都应该有针对于锁的一些操作，所以说就这样设计了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>  &#123;</span><br><span class="line">        <span class="comment">//一把锁</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">o1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (o1)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;锁在我这，就是造&quot;</span>);</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                    System.out.println(<span class="string">&quot;我等待挂起一下 &quot;</span>);</span><br><span class="line">                    o1.wait();</span><br><span class="line">                    System.out.println(<span class="string">&quot;线程1结束&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (o1)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;我拿到锁了&quot;</span>);</span><br><span class="line">                o1.notify();</span><br><span class="line">                System.out.println(<span class="string">&quot;唤醒你，等我执行完，你再执行&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;线程2结束&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>对象锁的<code>wait()</code>方法会暂时使得此线程进入等待状态，同时会释放当前代码块持有的锁。</p>
<p>其他线程就可以获取到此对象的锁，当其他线程调用对象的<code>notify()</code>方法后，会唤醒刚才变成等待状态的线程（这时并没有立即释放锁）。注意，必须是在持有锁（同步代码块内部）的情况下使用，否则会抛出异常！</p>
<p>notifyAll其实和notify一样，也是用于唤醒，但是前者是唤醒所有调用<code>wait()</code>后处于等待的线程，而后者是看运气随机选择一个。</p>
<h3 id="ThreadLocal的使用"><a href="#ThreadLocal的使用" class="headerlink" title="ThreadLocal的使用"></a>ThreadLocal的使用</h3><p>既然每个线程都有一个自己的工作内存，那么能否只在自己的工作内存中创建变量仅供线程自己使用？</p>
<p>就需要使用ThreadLocal来存储本地线程的变量，如果需要线程的线程可以使用，那就需要使用到InheritableThreadLocal类来存储本地变量。</p>
<p>具体的测试，如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">       <span class="comment">//定义了一个ThreadLocal泛型类别的当地线程变量</span></span><br><span class="line">        ThreadLocal&lt;String&gt; tempString = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line">       <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">           tempString.set(<span class="string">&quot;这是一个测试1&quot;</span>);</span><br><span class="line">           System.out.println(<span class="string">&quot;变量地址:&quot;</span>+tempString);<span class="comment">//查看地址</span></span><br><span class="line">           System.out.println(tempString.get());<span class="comment">//查看值</span></span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               Thread.sleep(<span class="number">1000</span>);<span class="comment">//确保子线程的子线程能够在之后运行</span></span><br><span class="line">           &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">               System.out.println(tempString.get());</span><br><span class="line">           &#125;).start();<span class="comment">//这里经过测试必须使用run来启动因为只有这样才可以创建子线程的子线程。</span></span><br><span class="line">       &#125;);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            tempString.set(<span class="string">&quot;这是一个测试2&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;变量地址:&quot;</span>+tempString);<span class="comment">//查看地址一样</span></span><br><span class="line">            System.out.println(tempString.get());<span class="comment">//查看值不同，两者在不同空间</span></span><br><span class="line">        &#125;);</span><br><span class="line">       thread1.start();</span><br><span class="line">       Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">       thread2.start();</span><br><span class="line">       Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">       <span class="comment">//如果要在子线程当中使用ThreadLocal那么需要使用一个新的类InheritableThreadLocal</span></span><br><span class="line">        InheritableThreadLocal&lt;String&gt; inheritableThreadLocal = <span class="keyword">new</span> <span class="title class_">InheritableThreadLocal</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            inheritableThreadLocal.set(<span class="string">&quot;我是可以继承的本地线程变量&quot;</span>);</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">                System.out.println(inheritableThreadLocal.get());</span><br><span class="line">            &#125;).start();</span><br><span class="line">            System.out.println(inheritableThreadLocal.get());</span><br><span class="line">        &#125;);</span><br><span class="line">        thread3.start();</span><br><span class="line">    &#125;			</span><br></pre></td></tr></table></figure>

<h3 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h3><p>我们有时候会有这样的需求，我希望定时执行任务，比如1秒后执行，或则1秒的循环执行，其实我们可以通过使用<code>Thread.sleep()</code>来实现：</p>
<p>如下面代码所示，我使用了Thread类来简单实现了这两种功能。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">TimeTask</span> <span class="variable">timeTask</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TimeTask</span>(<span class="number">1000</span>,<span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;haha&quot;</span>);</span><br><span class="line">        &#125;));</span><br><span class="line">        <span class="comment">//timeTask.timeTempStart();</span></span><br><span class="line">        timeTask.timeLoopRun();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">TimeTask</span>&#123;</span><br><span class="line">        <span class="type">long</span> time ;</span><br><span class="line">        Thread thread;</span><br><span class="line">        TimeTask()&#123;&#125;;</span><br><span class="line">        TimeTask(<span class="type">long</span> time,Thread thread)&#123;</span><br><span class="line">            <span class="built_in">this</span>.time = time;</span><br><span class="line">            <span class="built_in">this</span>.thread = thread;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">timeTempStart</span><span class="params">()</span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(time);</span><br><span class="line">                thread.start();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//对比之前的暂停启动多了一个while死循环。</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">timeLoopRun</span><span class="params">()</span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">                    Thread.sleep(time);</span><br><span class="line">                    thread.run();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>但是Java本身就要其封装的定时器，让我们来看的使用一下，使用Timer类。</p>
<p>如下代码所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Timer</span> <span class="variable">timer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Timer</span>();</span><br><span class="line">        timer.schedule(<span class="keyword">new</span> <span class="title class_">TimerTask</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">                timer.cancel();<span class="comment">//这里很重要，不明白看源码，取消Timer内部的任务队列，不然任务不结束。</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h3><p>不要把操作系统重的守护进程和守护线程相提并论！</p>
<p>守护进程在后台运行运行，不需要和用户交互，本质和普通进程类似。而守护线程就不一样了，当其他所有的非守护线程结束之后，守护线程自动结束，也就是说，Java中所有的线程都执行完毕后，守护线程自动结束，因此守护线程不适合进行IO操作，只适合打打杂。它会在所有的线程结束之后，结束，但是在这过程当中它是不断运行的。</p>
<p>如下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;我在运行中&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    thread.setDaemon(<span class="literal">true</span>);<span class="comment">//必须先标注守护线程再启动，不然报错</span></span><br><span class="line">    thread.start();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同是守护线程的子线程还是守护线程。<br>如下代码所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">        <span class="comment">//嵌套一个子线程也是守护线程</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;我在运行中&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;);</span><br><span class="line">    thread.setDaemon(<span class="literal">true</span>);<span class="comment">//必须先标注守护线程再启动，不然报错</span></span><br><span class="line">    thread.start();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="再谈集合类"><a href="#再谈集合类" class="headerlink" title="再谈集合类"></a>再谈集合类</h3><p>集合类中有一个东西是Java8新增的Spliterator接口，翻译过来就是：可拆分迭代器（Splitable Iterator）和Iterator一样，Spliterator也用于遍历数据源中的元素，但它是为了并行执行而设计的。Java 8已经为集合框架中包含的所有数据结构提供了一个默认的Spliterator实现。在集合跟接口Collection中提供了一个<code>spliterator()</code>方法用于获取可拆分迭代器。</p>
<p>其实我们之前在讲解集合类的根接口时，就发现有这样一个方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">default</span> Stream&lt;E&gt; <span class="title function_">parallelStream</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> StreamSupport.stream(spliterator(), <span class="literal">true</span>); <span class="comment">//parallelStream就是利用了可拆分迭代器进行多线程操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>并行流，其实就是一个多线程执行的流，它通过默认的ForkJoinPool实现（这里不讲解原理），它可以提高你的多线程任务的速度。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(Arrays.asList(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>));</span><br><span class="line">        <span class="comment">//这是使用多线程读取，各个线程读完打印</span></span><br><span class="line">        list</span><br><span class="line">                .parallelStream()</span><br><span class="line">                .forEach(i-&gt; System.out.println(Thread.currentThread().getName()+<span class="string">&quot;-&gt;&quot;</span>+i));</span><br><span class="line">        <span class="comment">//这是使用多线程读取，但是按顺序打印</span></span><br><span class="line">        list</span><br><span class="line">                .parallelStream()</span><br><span class="line">                .forEachOrdered(System.out::println);<span class="comment">//使用单线程维持原本的顺序</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>还有就是在Arrays数组工具类中，也包含大量的并行方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">10</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>&#125;;</span><br><span class="line">    Arrays.parallelSort(arr);</span><br><span class="line">    System.out.println(Arrays.toString(arr));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="多线程实战：生产者和消费者"><a href="#多线程实战：生产者和消费者" class="headerlink" title="多线程实战：生产者和消费者"></a>多线程实战：生产者和消费者</h3><p>所谓的生产者消费者模型，是通过一个容器来解决生产者和消费者的强耦合问题。通俗的讲，就是生产者在不断的生产，消费者也在不断的消费，可是消费者消费的产品是生产者生产的，这就必然存在一个中间容器，我们可以把这个容器想象成是一个货架，当货架空的时候，生产者要生产产品，此时消费者在等待生产者往货架上生产产品，而当货架有货物的时候，消费者可以从货架上拿走商品，生产者此时等待货架出现空位，进而补货，这样不断的循环。</p>
<p>通过多线程编程，来模拟一个餐厅的2个厨师和3个顾客，假设厨师炒出一个菜的时间为3秒，顾客吃掉菜品的时间为4秒。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.print.DocFlavor;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> List&lt;Object&gt; shelve = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();<span class="comment">//柜台</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">chef1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(Main::addShelve);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">chef2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(Main::addShelve);</span><br><span class="line">        chef1.setName(<span class="string">&quot;厨师1&quot;</span>);</span><br><span class="line">        chef2.setName(<span class="string">&quot;厨师2&quot;</span>);</span><br><span class="line">        chef1.start();</span><br><span class="line">        chef2.start();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">customer1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(Main::tackShelve);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">customer2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(Main::tackShelve);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">customer3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(Main::tackShelve);</span><br><span class="line">        customer1.setName(<span class="string">&quot;顾客1&quot;</span>);</span><br><span class="line">        customer2.setName(<span class="string">&quot;顾客2&quot;</span>);</span><br><span class="line">        customer3.setName(<span class="string">&quot;顾客3&quot;</span>);</span><br><span class="line">        customer1.start();</span><br><span class="line">        customer2.start();</span><br><span class="line">        customer3.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">addShelve</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">synchronized</span> (shelve) &#123;</span><br><span class="line">                shelve.add(<span class="keyword">new</span> <span class="title class_">Object</span>());</span><br><span class="line">                System.out.println(<span class="keyword">new</span> <span class="title class_">Date</span>()+Thread.currentThread().getName()+<span class="string">&quot;上菜&quot;</span>);</span><br><span class="line">                shelve.notifyAll();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">tackShelve</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (shelve) &#123;</span><br><span class="line">                    <span class="keyword">while</span> (shelve.isEmpty()) &#123;</span><br><span class="line">                        shelve.wait();</span><br><span class="line">                    &#125;</span><br><span class="line">                    shelve.remove(<span class="number">0</span>);</span><br><span class="line">                    System.out.println(<span class="keyword">new</span> <span class="title class_">Date</span>()+Thread.currentThread().getName()+<span class="string">&quot;拿菜&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                Thread.sleep(<span class="number">4000</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>编程学习笔记</category>
      </categories>
      <tags>
        <tag>编程学习笔记</tag>
        <tag>更新中</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言一些浅薄的认识</title>
    <url>/2023/09/05/C%E8%AF%AD%E8%A8%80%E4%B8%80%E4%BA%9B%E6%B5%85%E8%96%84%E7%9A%84%E8%AE%A4%E8%AF%86/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>按照惯例先写前言，这是c语言的自我的一个检讨和梳理，仅代表自己浅薄的认识，内容只到结构体。如果想要有全面客观的了解建议看书籍《C primer plus》这本书，最好英文版。</p>
<span id="more"></span>
<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="在C语言之前的感觉"><a href="#在C语言之前的感觉" class="headerlink" title="在C语言之前的感觉"></a>在C语言之前的感觉</h2><p>从0到1到电脑，硬件的底层逻辑是简单电路到数字电路的实现，通过高电压表示1，低电压表示0，来实现二进制的运算和逻辑操作。<br>现在把视野从微观的电路实现脱离，来看看现在计算机的主要组成部分，硬件的组成就是I&#x2F;O设备<del>（输入，输出）</del>，计算<del>（运算，控制）</del>，存储。其中计算是核心，特别是CPU。<br>现在我们有了硬件，如何让硬件发挥功效，以及搭建软件的生态的底层，需要计算机操作系统的统筹，来给计算机注入灵活。<br>操作系统和硬件cpu的对话，可以让cpu发出各种指令，在物理层面实现各种结果。<br>之后视角转向我们的编程语言，cpu层面的机器语言，抽象出来是汇编语言，抽象出来是高级语言，高级语言分为面向过程的POP和面向对象的OOP。<br>而C语言是高级语言当中，唯一的POP，拥有仅次于机器语言，汇编语言的最高效率，是编写其他面向对象语言OOP的编程语言的母亲。</p>
<h2 id="C语言基础语法的感觉"><a href="#C语言基础语法的感觉" class="headerlink" title="C语言基础语法的感觉"></a>C语言基础语法的感觉</h2><p>面向过程重要的是开始和结束，在初学c语言的时候main函数进入,retrun 0结尾，就是一张一合的黑箱。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//this is other demo.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个感觉贯穿了c语言的始终，是思考的open与close。<br>在编写c语言的时候，始终和内存紧密相连，变量在数据中的存储，所占的字节都是RAM的空间。如果是数组就要遵循back to back的原则，拥有一块完整的index索引。<br>从位到字节，从字节到变量，其本质只是被抽象提炼，可以逐步下放。<br>以下方demo为例</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> c = <span class="number">127</span>;    </span><br><span class="line">c = c + <span class="number">1</span>;   </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, c);<span class="comment">//结果输出-128</span></span><br></pre></td></tr></table></figure>
<p>输出-128是因为在位数上从0111 1111变成了1111 1111。<br>如果不了解基本位运算就无法解释，两者的连接关系。从数字电路的0，1逻辑运算，伴随的机器语言，汇编语言，到C语言，联系始终没有断掉，你依然可以使用这种独特的计算机写法。<br>如果熟练使用位运算，在某些方面可能会有奇效，比如&lt;&lt;，&gt;&gt;，|，^,&amp;,这些都是计算机底层的运算逻辑。写代码不能忽视计算机的整体，一直体现在高级语言当中，是统一的。<br>变量当中会进行自动的转换，char(1 byte),short(2 byte)-&gt;int(4 byte)-&gt;unsgined int(4 byte)-&gt;long(8 byte)-&gt;double(8 byte)&lt;-float(4 byte)<br>char和short在运算当中会转换为int,float在运算中会转换为double。<br>只有因为精度的问题，我们才会使用强制转换。<br>比如double &#x3D; int&#x2F;float 和 double &#x3D; int&#x2F;int相比保留了小数的精度，都是由变量在内存RAM的存储过程中所决定生效的机制。从基础电路一直延续到C，是底层原理决定的上层的应用。 </p>
<p>变量之后就是顺序，选择，循环这三种不同的逻辑形式，构成了编程语言的逻辑表达。<br>其中循环是最为重要的部分，for,while default,break中断循环，continue加速循环，return终结一切。</p>
<p>此外，在表达的过程当中，还要考虑人们的语言问题就转换成编程语言的编码问题，国际化常用UTF-8，中国常用GBK。都是底层存储的原因，具体可以自己比较看看ASCII码128个字符是多么的有限。</p>
<h2 id="C语言高级特性的感觉"><a href="#C语言高级特性的感觉" class="headerlink" title="C语言高级特性的感觉"></a>C语言高级特性的感觉</h2><p>函数是特定任务的独立代码单元，能够减轻优化代码量，进行一定程度的抽象。<br>有了函数的存在，程序入口的main函数才能成为最简洁的存在，真正的main函数是应该一眼就能看完，剩下的所有都应该交给抽象的函数去处理。如下图的例子。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    run();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">run()&#123;</span><br><span class="line">    <span class="comment">//其他运行的函数。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这才是简洁的存在，抽象之后的干净，有了函数之后，就要考虑变量的传入，分为值传入和地址传入，这又要考虑内存的存在，引出指针来指向内存的修改是完整的进去，而如果是值则是粘贴复制。<br>函数还有的作用就是自己调用自己的递归，具体的实现是函数调用的原理是一个Stack，当然这个Stack是由限制的，如果过多的调用，就会撑爆这个函数调用栈，从而出现stack overflow的错误。<br>指针作为一种C语言的灵魂，赋予了C语言强大的功能，如同人的影子，指针代表一种指向，可以指向各种变量，数组，函数等。是直接访问内存的一个直接手段。<br>结构体是面向对象的萌芽，是多个变量的捆绑，需要注意的是结构体在内存当中的存储，取决于变量类型的最大的那个的整数倍。<br>与结构体相对应的是联合体它在内存当中是共用一块空间，取决于联合体当中，变量类型存储空间最大的那块内存空间。<br>在使用结构体的时候常常伴随的typedef来其别名，并且需要编写头文件来声明，.c文件来引用头文件来实现，使用malloc申请返回void无指针类型的空间大小，配合的free释放函数内存的方法，其实把这些组合起来，非常像面向对象，只剩下了呼之欲出。</p>
]]></content>
      <categories>
        <category>编程学习笔记</category>
      </categories>
      <tags>
        <tag>编程学习笔记</tag>
        <tag>完结</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaSE一些浅薄的认识</title>
    <url>/2023/09/07/JavaSE%E4%B8%80%E4%BA%9B%E6%B5%85%E8%96%84%E7%9A%84%E8%AE%A4%E8%AF%86/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>按照惯例先写前言，JavaSE是Java当中基础的部分这里针对JavaSE的知识进行一个整体的构建，以便有一个大致像样的模型可以看待问题，只是浅薄的认识，可能有误，具体的请看JDK的源码或则官方文档来进一步了解Java语言。</p>
<span id="more"></span>
<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="Java基础部分"><a href="#Java基础部分" class="headerlink" title="Java基础部分"></a>Java基础部分</h2><p>Java语言是面向对象的语言，它最主要的特性是它的跨平台性，一次编写全平台使用，全平台的实现则是由JVM实现的。<br>代码是通过编译成.class的二进制文件交给JVM去各个平台上运行。</p>
<p>从Java开始C语言的Main函数就变成了Main方法，称呼的转变意味着思维的转变，也就是从POP到OOP。</p>
<p>在基本类型当中，Java语言整数类型有byte,short,int,long，其中int是默认整数类型。<br>Java语言的浮点类型有float,double，其中double是默认浮点类型。<br>字符类型则是char,这里的char是两字节的存储，比起C语言1字节的char，可以存储中文单个字符了，容量更大更多。</p>
<p>隐式转换的顺序：<br>byte-&gt;short-&gt;int-&gt;long-&gt;float-&gt;double<br>没错，八字节的long转换为4字节的float，因为float是指数增长的浮点类型，从表示的范围来看比整数long要大，这是底层存储原理所决定的。</p>
<p>在C语言当中，变量如果不赋值我们都可以运行，会随意把内存当中的值展现出来，但是Java是默认给你阉割掉给你默认值，如果是引用则是null，如果是整数类型是0,如果是浮点类型是0.0。</p>
<p>另外谈起char就要谈起编码问题，unicode是”字符集”，utf-8,utf-16,gbk是编码规则。<br>在面向对象当中我们就很少用到char了，我们用引用类型String。<br>String不是基本类型，是一个对象类型，一个引用类型，是指向内存一段空间的类型。</p>
<p>说起内存就要说说底层的位运算并没有发生改变,|（位或），&amp;（位与）,^（位异或）,~（位非）,&lt;&lt;（位左移）,&gt;&gt;（位右移）。这代表的从数字电路到CPU到机器语言到汇编语言到C语言到Java语言是一脉单传的特性，是一种协调的有机。</p>
<p>在Java语言里面，C语言的指针被引用所替代。<br>请看下面的例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="variable">Freezelook</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line"><span class="type">Person</span> <span class="variable">PFreezelook</span> <span class="operator">=</span> Freezelook;</span><br></pre></td></tr></table></figure>
<p>如果在C语言，是PFreezelook指向了Freezelook，是指针，但是Java面向对象当中并不像C语言的设计理念那样全新全意相信程序员，把指针砍掉了，为了安全，因为指针的特点是可以指向各种内存，甚至是操作系统当中的内存。所以这里是引用，他们是同一块的内存空间，是一个引用。还有一个角度就是看new，new如果在C语言当中就是引用&lt;stdlib.h&gt;当中的malloc开辟一块内存空间，来存放一个Person对象。</p>
<p>还是通过POP和OOP来进行比较<br>OOP当中的对象包含属性，方法，这一点连main都称呼为了主方法而不是主函数了。<br>POP当中与之对应的是结构体，函数，这一点依然是面向结果的导论。而OOP则是对外在事物的描述，刻画，临摹，所以画家和程序员有的自己共通性。具体请看《黑客与画家》这本书。</p>
<p>由于Java语言的封装性，我们常常会看不到一些隐藏的函数，比如说默认的构造函数之类的，我们该怎么查看呢？<br>答：通过反编译来查看，也就是查看.class二进制文件，这是交给JVM执行的全部信息，由于Java语言给程序员的权限没有C语言多，所以我们只能出此下策看看给JVM的文件是怎么提交的，很简单只需要用到原生JDK命令当中的javap就行了，或则使用IDEA去out文件夹下找到对应的文件，点两下就可以看到隐藏信息。</p>
<p>接下来进入面向对象思维集中体现的创造，类。<br>类有静态变量和静态方法，是类的属性和行为，有成员变量和成员方法，成员是类的对象的属性和行为。<br>在创建类的时候，首先是类，其次是对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="variable">Freezelook</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br></pre></td></tr></table></figure>
<p>如上面例子所示，从右到左，符合赋值运算，符合逻辑。<br>类是对对象的抽象，这么多类我们就需要包来进行管理，包是将类管理的一个重要概率。<br>在Java当中默认导入的就是java.lang.*所有的类。</p>
<p>类在其封装的时候有四种权限，对应的不同类之间互相访问的闸门。<br>private:自己<br>default:自己，和同包下的类。<br>protected:自己，后代，和同包下的类。<br>public:自己，后代，和同包下的类，和别的包的类。</p>
<p>类的继承是为了减轻写子代的代码的耦合性，也是为了发展第三个特性多态的前提。<br>类的对象是引用类型，是引用类型就有指针的感觉。<br>所以父类Person可以应用子类Student，但是使用只能使用父类的方法。<br>可以将其向下强制转型为Student，最好使用instanceof来进行Student的判断再进行。<br>如下方例子所示</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(java.lang.String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Person</span> <span class="variable">personStu</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();<span class="comment">//自动向上转换</span></span><br><span class="line">    System.out.println(personStu.toString());</span><br><span class="line">    <span class="keyword">if</span> (personStu <span class="keyword">instanceof</span> Student)&#123;</span><br><span class="line">        <span class="type">Student</span> <span class="variable">stu</span> <span class="operator">=</span> (Student) personStu;<span class="comment">//强制向下转换</span></span><br><span class="line">        System.out.println(stu.toString());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>打印出来的结果是同一个内存空间。</p>
<p>在子类对父类的续写代码中，静态方法可以被继承，但是无法被重写，因为父类的静态方法是父类的。<br>重写是不同子类重写父类同一个方法，表现出来的多种行为的状态，多态的桥梁是重写父类的方法所体现的。<br>在继承的过程当中，父类的权限不能比子类低，也就是封装性，如果父类是protected那么子类要么是public，要么是protected。子类只能提高父类的权限。</p>
<p>类是对对象的抽象，对象是对现实的临摹。<br>对类的抽象是抽象类，对抽象类的抽象是接口。<br>从抽象的程度来看：子类-》父类-》抽象类-》接口（无实体）。<br>抽象的目的是在代码层面消除重复。<br>接口可以多继承，子类引用的接口可以父类实现。<br>接口有静态成员和静态方法，静态成员和方法通过查询反编译是public static final [数据类型]的权限。</p>
<p>Java语言的基本类型，没有进行面向对象化。所以有了基本类型的封装类，我们称之为装箱拆箱，将面向对象进行到基本的数据类型，并给予相对应的方法。是面向对象设计思想的进一步延伸。<br>具体的包装基本类型的家谱如下图所示：<br><img src="https://image.itbaima.net/images/390/image-20230907134904924.jpeg" alt="包装基本类型的家谱"></p>
<p>因为基本类型的普遍使用，所以Java支持自动的装箱和拆箱操作。<br>如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;<span class="comment">//&lt;=&gt;Integer a = Integer.valueOf(10);</span></span><br><span class="line"><span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> a;<span class="comment">//&lt;=&gt;int b = a.intValue();</span></span><br></pre></td></tr></table></figure>
<p>其中需要注意的是在自动拆转箱的过程当中，Java为了节省内存空间，设置了一个-128到127的缓存机制（仅Integer而言，其他类似），这里的对象指向同一个内存的引用。<br>把这些基本类型包装，是为了引出后面的特殊类型BigInteger和BigDecimal。一个可以装的足够大，一个可以保证足够的精度。</p>
<p>数组的本质也是类，其实现的底层是C++所写的，创建数组的时候我们同样需要new一块空间去引用就是明确的证明。<br>由于基本数据类型的存在int[] arr &#x3D; new int[10],并不能被Object类所向上转换。这里就明白了装箱的作用了，是把这些基本类型引入面向对象的体系当中去。<br>如下图所示，会报错</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];</span><br><span class="line">Object[] test = arr;<span class="comment">//报错，因为是基本类型，不属于面向对象体系，是面向过程残余。</span></span><br></pre></td></tr></table></figure>
<p>如果换成Intger就好了，如下所示</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer[] arr = <span class="keyword">new</span> <span class="title class_">Integer</span>[<span class="number">10</span>];</span><br><span class="line">Object[] test = arr;<span class="comment">//同是面向对象体系，被父类所承认。</span></span><br></pre></td></tr></table></figure>
<p>就是面向对象的一脉。</p>
<p>String字符串是引用类型，一旦创建无法修改，主方法的String[] args也是如此。如果需要修改需要使用StringBuilder（线程高效）或则StringBuffer（线程安全）。<br>如果我们需要识别一个特殊的字符串，我们需要使用正则表达式。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;<span class="comment">//matches方法用于对给定正则表达式进行匹配，匹配成功返回true，否则返回false</span></span><br><span class="line">System.out.println(str.matches(<span class="string">&quot;a+&quot;</span>));<span class="comment">//+表示对前面这个字符匹配一次或多次</span></span><br></pre></td></tr></table></figure>

<p>内部类可以分为成员的内部类，静态的内部类，局部的内部类。<br>匿名内部类主要实现抽象类和接口的初始化（普通的类也行），属于一个没有名字的子类。<br>内部类在编译的过程当中，生成的.class文件会和其包含的它的类的分离。属于单独的一个类。</p>
<p>Lambda针对的是接口有一个待实现的方法简写实现的简洁语法。</p>
<ul>
<li>标准格式为：<code>([参数类型 参数名称,]...) ‐&gt; &#123; 代码语句，包括返回值 &#125;</code></li>
<li>和匿名内部类不同，Lambda仅支持接口，不支持抽象类</li>
<li>接口内部必须有且仅有一个抽象方法（可以有多个方法，但是必须保证其他方法有默认实现，必须留一个抽象方法出来）<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Sum</span> <span class="variable">sum1</span> <span class="operator">=</span> (a, b) -&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;&#125;</span><br><span class="line"><span class="type">Sum</span> <span class="variable">sum2</span> <span class="operator">=</span> (a,b)-&gt;a+b;</span><br><span class="line"><span class="type">Sum</span> <span class="variable">sum3</span> <span class="operator">=</span> Main::Sum1;</span><br></pre></td></tr></table></figure>
为什么使用Lambda，是因为方便并且简洁的美。</li>
</ul>
<p>异常类型本质还是类，是运行时的异常，写出异常是为了避免错误，进行一个mark。<br>异常不是错误，不是一个致命的问题，错误是致命的问题。<br>异常分为两种，编译时的异常，运行时的异常。<br>家谱为接口-Serializable<br>类-Throwable<br>-Exception    Error<br>-RuntimeException<br>对异常的处理，<br>1.可以继续throw<br>2.使用try catch finally。</p>
<p>泛型概念的提出是为了解决既要又要的问题，如果一个值，比如学生的成绩我们需要同时传入Integer和String，那就要使用泛型了。<br>泛型是待定类型，用到的时候才会具体，泛型将数据类型的确定控制在编码的阶段，如果没有给泛型一个确切的回答，那么会默认到它的上界，也就是Object类，所有类的父类。<br>除了指定待编译的数据类型，也可以用？来指定任意类型(默认的上界是Object类)。<br>泛型广泛存在于类，接口，方法，变量当中。<br>泛型设置上界的关键字extend继承，是把默认的Object类指定到别的父类。<br>设置下界的关键字super，要和？进行搭配。<br>泛型只是在编码过程当中存在，交给机器执行的时候，会将泛型类型擦除，只有上界的存在，通常是Object类。但是为了方便我们敲代码，泛型还是方便，但是我们需要知道它的内核是父类指向子类的引用。</p>
<p>集合类的底层是数据结构构成的，通过看Java源码，自底向上的学习是最好的方法。<br>线性表List（父类），可以使用ArrayList（子类，底层动态数组），LinkedList（子类，底层链表）。</p>
<p>迭代器是集合当中包装的一个机制，针对不同类型的底层实现，使用不同的迭代器，使用统一的方式进行遍历。是一个通用的遍历工具。<br>迭代器通常是一次性使用的，Iterable接口可以表示这个类实现了迭代器的相关功能。这就代表了它们可以使用了foreach增强for循环。<br>迭代器的实现底层代码关键在于hasNest()方法和next()方法，一个方式是下一个是否存在，另外一个是读取数据，让hasNest下一个()，很有指针的感觉。</p>
<p>Deque(双端队列，可以当栈来使用)和Queue(普通队列)，一个实现多种用途用链表来实现如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Deque&lt;String&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br></pre></td></tr></table></figure>

<p>Set集合底层是hashSet，Set具有不能重复使用，随机访问的特性，Set相当于Map当中&lt; key,value &gt;的value部分的合集，实际上Set的底层实现也是调用的Map的方法。<br>下面是new一个Set</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Set&lt;String&gt;set1 = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();<span class="comment">//一个标准的Set集合</span></span><br><span class="line">Set&lt;String&gt;set1 = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;();<span class="comment">//有的顺序排序的Set集合，链表实现</span></span><br><span class="line">Set&lt;String&gt;set1 = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;();<span class="comment">//一个自动排序的Set集合，底层是树。</span></span><br></pre></td></tr></table></figure>

<p>前面说过Set是Map的外壳，Map映射并不受制于Collection是一个独立的体系。主要是key键，Value值对来组成的映射关系。</p>
<p>Stream流是对于上面集合调用的一种综合写法，可以让代码写的更加优雅，简洁，相当于工厂的流水线有着自己格式。</p>
<p>I&#x2F;O流存在的原因是扩展程序编程范围到了文件系统，去读取操纵操作系统上的文件系统，I&#x2F;O流是通过内存来到存储空间进行流传输的。<br>由于启用流需要关闭，不然文件一直会被占用，在别的方面可能会报错，所以有了便捷的写法try(流 &#x3D; new 流()){}catch{}</p>
<p>要有流的感觉需要看一个byte一个byte传，还是使用缓存空间很多很多的byte传，用比喻的话就是，水龙头开水是大水还是小水。字节在其中是传输的最基础单位。</p>
<p>字节流，InputStream,OutputStream<br>字符流 FileReader FileWrite（纯文本操作）<br>文件流（文件夹） File FileInputStream FileOutputStream</p>
<p>暂时缓存区存在的原因，归根于底层硬件，因为硬盘的读取速度和内存相比是满的，而我们程序操纵内存太快了完成，需要等硬盘到内存的传输，所以需要加大流量，使用缓冲流，概念因此产生。</p>
<p>缓存流的的类：BufferedInputStream（包InputStream） BufferedOutputStream（包OutputStream） BufferedReader（包FileReader） BufferedWriter（包FileWriter）</p>
<p>缓存流和前文的HashSet底层调用HashMap一样，它的底层调用用本的流，加上了缓冲区，是一种装饰者模式。</p>
<p>I&#x2F;O流本身自能够单向的流一遍，不能倒回去流，缓冲流另外的一个好处，就是缓冲区的存在，使着倒回去流存在。具体的代码实现mark()（标记）,reset()（回溯到mark标记处）</p>
<p>常见的流当中，最主要的是Scanner（System.in）控制台的输入流和System.out.printf控制台的输出流。</p>
<p>在类的对象当中，一个类如果支持对象流的输入和输出，它的底层代码需要实现对象序列化流的接口SeriaLizable，如果在类当中，不想某个类的属性被序列化，需要使用transient关键字来避免。</p>
<p>下面就开始多线程了，我会在主页的另外一个博文单独拧出来总结，放这里就显得冗余了。<br>具体的地址为：<a href="https://freezedem.github.io/2023/10/11/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%8F%8D%E5%B0%84/">点击</a></p>
]]></content>
      <categories>
        <category>编程学习笔记</category>
      </categories>
      <tags>
        <tag>编程学习笔记</tag>
        <tag>完结</tag>
      </tags>
  </entry>
  <entry>
    <title>Learning Git Branching 在线游戏 学习记录</title>
    <url>/2023/08/28/Learning-Git-Branching-%E5%9C%A8%E7%BA%BF%E6%B8%B8%E6%88%8F-%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>游戏有如下的关卡：</p>
<ul>
<li>基础篇3关，</li>
<li>高级篇3关，</li>
<li>移动提交记录2个，</li>
<li>杂项5个，</li>
<li>高级话题3个，</li>
<li>git远程仓库8个</li>
<li>git远程仓库高级操作8个<span id="more"></span></li>
</ul>
<h2 id="基础篇"><a href="#基础篇" class="headerlink" title="基础篇"></a>基础篇</h2><h3 id="Git-Commit"><a href="#Git-Commit" class="headerlink" title="Git Commit"></a>Git Commit</h3><p>Git 仓库中的提交记录保存的是你的目录下所有文件的快照，就像是把整个目录复制，然后再粘贴一样，但比复制粘贴优雅许多！   </p>
<p>Git 希望提交记录尽可能地轻量，因此在你每次进行提交时，它并不会盲目地复制整个目录。条件允许的情况下，它会将当前版本与仓库中的上一个版本进行对比，并把所有的差异打包到一起作为一个提交记录。    </p>
<h3 id="Git-Branch"><a href="#Git-Branch" class="headerlink" title="Git Branch"></a>Git Branch</h3><p>Git 的分支也非常轻量。它们只是简单地<strong>指向</strong>某个提交纪录 —— 仅此而已。所以许多 Git 爱好者传颂：<br><strong>早建分支！多用分支！</strong><br>这是因为即使创建再多的分支也不会造成储存或内存上的开销，并且按逻辑分解工作到不同的分支要比维护那些特别臃肿的分支简单多了。</p>
<p>注意：在 Git 2.23 版本中，引入了一个名为 git switch 的新命令，最终会取代 git checkout，因为 checkout 作为单个命令有点超载（它承载了很多独立的功能）。 由于现在很多人还无法使用 switch，本次课程仍然使用 checkout 而不是 switch， 但是如果你想尝试一下新命令，我们的应用也是支持的！并且你可以从<a href="https://git-scm.com/docs/git-switch">这里</a>学到更多关于新命令的内容。</p>
<h3 id="Git-Merge"><a href="#Git-Merge" class="headerlink" title="Git Merge"></a>Git Merge</h3><p>太好了! 我们已经知道如何提交以及如何使用分支了。接下来咱们看看如何将两个分支合并到一起。就是说我们新建一个分支，在其上开发某个新功能，开发完成后再合并回主线。</p>
<p>咱们先来看一下第一种方法 —— git merge。在 Git 中合并两个分支时会产生一个特殊的提交记录，它有两个 parent 节点。翻译成自然语言相当于：“我要把这两个 parent 节点本身及它们所有的祖先都包含进来。”</p>
<h3 id="Git-Rebase"><a href="#Git-Rebase" class="headerlink" title="Git Rebase"></a>Git Rebase</h3><p>第二种合并分支的方法是 git rebase。Rebase 实际上就是取出一系列的提交记录，“复制”它们，然后在另外一个地方逐个的放下去。</p>
<p>Rebase 的优势就是可以创造更线性的提交历史，这听上去有些难以理解。如果只允许使用 Rebase 的话，代码库的提交历史将会变得异常清晰。</p>
<h2 id="高级篇"><a href="#高级篇" class="headerlink" title="高级篇"></a>高级篇</h2><h3 id="HEAD"><a href="#HEAD" class="headerlink" title="HEAD"></a>HEAD</h3><p>HEAD 是一个对当前所在分支的符号引用 —— 也就是指向你正在其基础上进行工作的提交记录。</p>
<p>HEAD 总是指向当前分支上最近一次提交记录。大多数修改提交树的 Git 命令都是从改变 HEAD 的指向开始的。</p>
<p>HEAD 通常情况下是指向分支名的（如 bugFix）。在你提交时，改变了 bugFix 的状态，这一变化通过 HEAD 变得可见。</p>
<h3 id="相对引用"><a href="#相对引用" class="headerlink" title="相对引用"></a>相对引用</h3><p>通过指定提交记录哈希值的方式在 Git 中移动不太方便。在实际应用时，并没有像本程序中这么漂亮的可视化提交树供你参考，所以你就不得不用 git log 来查查看提交记录的哈希值。</p>
<p>并且哈希值在真实的 Git 世界中也会更长（译者注：基于 SHA-1，共 40 位）。例如前一关的介绍中的提交记录的哈希值可能是 fed2da64c0efc5293610bdd892f82a58e8cbc5d8。舌头都快打结了吧…</p>
<p>比较令人欣慰的是，Git 对哈希的处理很智能。你只需要提供能够唯一标识提交记录的前几个字符即可。因此我可以仅输入fed2 而不是上面的一长串字符。<br>正如我前面所说，通过哈希值指定提交记录很不方便，所以 Git 引入了相对引用。这个就很厉害了!</p>
<p>使用相对引用的话，你就可以从一个易于记忆的地方（比如 bugFix 分支或 HEAD）开始计算。</p>
<p>相对引用非常给力，这里我介绍两个简单的用法：</p>
<p>使用 ^ 向上移动 1 个提交记录<br>使用 ~&lt; num &gt; 向上移动多个提交记录，如 ~3</p>
<p>“~”操作符<br>如果你想在提交树中向上移动很多步的话，敲那么多 ^ 貌似也挺烦人的，Git 当然也考虑到了这一点，于是又引入了操作符 ~。</p>
<p>该操作符后面可以跟一个数字（可选，不跟数字时与 ^ 相同，向上移动一次），指定向上移动多少次。咱们还是通过实际操作看一下吧</p>
<h3 id="撤销变更"><a href="#撤销变更" class="headerlink" title="撤销变更"></a>撤销变更</h3><p>在 Git 里撤销变更的方法很多。和提交一样，撤销变更由底层部分（暂存区的独立文件或者片段）和上层部分（变更到底是通过哪种方式被撤销的）组成。我们这个应用主要关注的是后者。</p>
<p>主要有两种方法用来撤销变更 —— 一是 git reset，还有就是 git revert。接下来咱们逐个进行讲解。</p>
<p>git reset 通过把分支记录回退几个提交记录来实现撤销改动。你可以将这想象成“改写历史”。git reset 向上移动分支，原来指向的提交记录就跟从来没有提交过一样。</p>
<p>虽然在你的本地分支中使用 git reset 很方便，但是这种“改写历史”的方法对大家一起使用的远程分支是无效的哦！</p>
<p>为了撤销更改并分享给别人，我们需要使用 git revert。</p>
<h2 id="移动提交记录"><a href="#移动提交记录" class="headerlink" title="移动提交记录"></a>移动提交记录</h2><h3 id="Git-Cherry-pick"><a href="#Git-Cherry-pick" class="headerlink" title="Git Cherry-pick"></a>Git Cherry-pick</h3><p>本系列的第一个命令是 git cherry-pick, 命令形式为:</p>
<p>git cherry-pick &lt;提交号&gt;…<br>如果你想将一些提交复制到当前所在的位置（HEAD）下面的话， Cherry-pick 是最直接的方式了。我个人非常喜欢 cherry-pick，因为它特别简单。</p>
<h3 id="交互式的-rebase"><a href="#交互式的-rebase" class="headerlink" title="交互式的 rebase"></a>交互式的 rebase</h3><p>当你知道你所需要的提交记录（并且还知道这些提交记录的哈希值）时, 用 cherry-pick 再好不过了 —— 没有比这更简单的方式了。</p>
<p>但是如果你不清楚你想要的提交记录的哈希值呢? 幸好 Git 帮你想到了这一点, 我们可以利用交互式的 rebase —— 如果你想从一系列的提交记录中找到想要的记录, 这就是最好的方法了</p>
<p>交互式 rebase 指的是使用带参数 –interactive 的 rebase 命令, 简写为 -i</p>
<p>如果你在命令后增加了这个选项, Git 会打开一个 UI 界面并列出将要被复制到目标分支的备选提交记录，它还会显示每个提交记录的哈希值和提交说明，提交说明有助于你理解这个提交进行了哪些更改。</p>
<h2 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h2><h3 id="本地栈式提交"><a href="#本地栈式提交" class="headerlink" title="本地栈式提交"></a>本地栈式提交</h3><p>来看一个在开发中经常会遇到的情况：我正在解决某个特别棘手的 Bug，为了便于调试而在代码中添加了一些调试命令并向控制台打印了一些信息。</p>
<p>这些调试和打印语句都在它们各自的提交记录里。最后我终于找到了造成这个 Bug 的根本原因，解决掉以后觉得沾沾自喜！</p>
<p>最后就差把 bugFix 分支里的工作合并回 main 分支了。你可以选择通过 fast-forward 快速合并到 main 分支上，但这样的话 main 分支就会包含我这些调试语句了。你肯定不想这样，应该还有更好的方式……</p>
<p>实际我们只要让 Git 复制解决问题的那一个提交记录就可以了。跟之前我们在“整理提交记录”中学到的一样，我们可以使用</p>
<p>git rebase -i<br>git cherry-pick<br>来达到目的。</p>
<h3 id="提交的技巧-1"><a href="#提交的技巧-1" class="headerlink" title="提交的技巧 #1"></a>提交的技巧 #1</h3><p>接下来这种情况也是很常见的：你之前在 newImage 分支上进行了一次提交，然后又基于它创建了 caption 分支，然后又提交了一次。</p>
<p>此时你想对某个以前的提交记录进行一些小小的调整。比如设计师想修改一下 newImage 中图片的分辨率，尽管那个提交记录并不是最新的了。</p>
<p>我们可以通过下面的方法来克服困难：</p>
<p>先用 git rebase -i 将提交重新排序，然后把我们想要修改的提交记录挪到最前<br>然后用 git commit –amend 来进行一些小修改<br>接着再用 git rebase -i 来将他们调回原来的顺序<br>最后我们把 main 移到修改的最前端（用你自己喜欢的方法），就大功告成啦！<br>当然完成这个任务的方法不止上面提到的一种（我知道你在看 cherry-pick 啦），之后我们会多点关注这些技巧啦，但现在暂时只专注上面这种方法。</p>
<h3 id="提交的技巧-2"><a href="#提交的技巧-2" class="headerlink" title="提交的技巧 #2"></a>提交的技巧 #2</h3><p>正如你在上一关所见到的，我们可以使用 rebase -i 对提交记录进行重新排序。只要把我们想要的提交记录挪到最前端，我们就可以很轻松的用 –amend 修改它，然后把它们重新排成我们想要的顺序。</p>
<p>但这样做就唯一的问题就是要进行两次排序，而这有可能造成由 rebase 而导致的冲突。下面还是看看 git cherry-pick 是怎么做的吧。</p>
<h3 id="Git-Tags"><a href="#Git-Tags" class="headerlink" title="Git Tags"></a>Git Tags</h3><p>相信通过前面课程的学习你已经发现了：分支很容易被人为移动，并且当有新的提交时，它也会移动。分支很容易被改变，大部分分支还只是临时的，并且还一直在变。</p>
<p>你可能会问了：有没有什么可以永远指向某个提交记录的标识呢，比如软件发布新的大版本，或者是修正一些重要的 Bug 或是增加了某些新特性，有没有比分支更好的可以永远指向这些提交的方法呢？</p>
<p>当然有了！Git 的 tag 就是干这个用的啊，它们可以（在某种程度上 —— 因为标签可以被删除后重新在另外一个位置创建同名的标签）永久地将某个特定的提交命名为里程碑，然后就可以像分支一样引用了。</p>
<p>更难得的是，它们并不会随着新的提交而移动。你也不能切换到某个标签上面进行修改提交，它就像是提交树上的一个锚点，标识了某个特定的位置。</p>
<h3 id="Git-Describe"><a href="#Git-Describe" class="headerlink" title="Git Describe"></a>Git Describe</h3><p>由于标签在代码库中起着“锚点”的作用，Git 还为此专门设计了一个命令用来描述离你最近的锚点（也就是标签），它就是 git describe！</p>
<p>Git Describe 能帮你在提交历史中移动了多次以后找到方向；当你用 git bisect（一个查找产生 Bug 的提交记录的指令）找到某个提交记录时，或者是当你坐在你那刚刚度假回来的同事的电脑前时， 可能会用到这个命令。</p>
<p>git describe 的​​语法是：</p>
<p>git describe &lt; ref &gt;</p>
<p>&lt; ref &gt; 可以是任何能被 Git 识别成提交记录的引用，如果你没有指定的话，Git 会使用你目前所在的位置（HEAD）。</p>
<p>它输出的结果是这样的：</p>
<p>&lt; tag &gt;_&lt; numCommits &gt;_g&lt; hash &gt;</p>
<p>tag 表示的是离 ref 最近的标签， numCommits 是表示这个 ref 与 tag 相差有多少个提交记录， hash 表示的是你所给定的 ref 所表示的提交记录哈希值的前几位。</p>
<p>当 ref 提交记录上有某个标签时，则只输出标签名称</p>
<h2 id="高级话题"><a href="#高级话题" class="headerlink" title="高级话题"></a>高级话题</h2><h3 id="多分支-rebase"><a href="#多分支-rebase" class="headerlink" title="多分支 rebase"></a>多分支 rebase</h3><p>哇，现在我们这里出现了很多分支呢！让我们把所有这些分支上所做的工作都通过 rebase 合并到 main 分支上吧。</p>
<p>但是你的领导给你提了点要求 —— 他们希望得到有序的提交历史，也就是我们最终的结果应该是 C6’ 在 C7’ 上面， C5’ 在 C6’ 上面，依此类推。</p>
<h3 id="选择-parent-提交记录"><a href="#选择-parent-提交记录" class="headerlink" title="选择 parent 提交记录"></a>选择 parent 提交记录</h3><p>操作符 ^ 与 ~ 符一样，后面也可以跟一个数字。</p>
<p>但是该操作符后面的数字与 ~ 后面的不同，并不是用来指定向上返回几代，而是指定合并提交记录的某个 parent 提交。还记得前面提到过的一个合并提交有两个 parent 提交吧，所以遇到这样的节点时该选择哪条路径就不是很清晰了。</p>
<p>Git 默认选择合并提交的“第一个” parent 提交，在操作符 ^ 后跟一个数字可以改变这一默认行为。例如HEAD^2</p>
<h3 id="纠缠不清的分支"><a href="#纠缠不清的分支" class="headerlink" title="纠缠不清的分支"></a>纠缠不清的分支</h3><p>多次使用git rebase相关即可通关。</p>
<h2 id="git远程仓库"><a href="#git远程仓库" class="headerlink" title="git远程仓库"></a>git远程仓库</h2><h3 id="git-clone"><a href="#git-clone" class="headerlink" title="git clone"></a>git clone</h3><p>远程仓库并不复杂, 在如今的云计算盛行的世界很容易把远程仓库想象成一个富有魔力的东西, 但实际上它们只是你的仓库在另个一台计算机上的拷贝。你可以通过因特网与这台计算机通信 —— 也就是增加或是获取提交记录</p>
<p>话虽如此, 远程仓库却有一系列强大的特性</p>
<p>首先也是最重要的的点, 远程仓库是一个强大的备份。本地仓库也有恢复文件到指定版本的能力, 但所有的信息都是保存在本地的。有了远程仓库以后，即使丢失了本地所有数据, 你仍可以通过远程仓库拿回你丢失的数据。</p>
<p>还有就是, 远程让代码社交化了! 既然你的项目被托管到别的地方了, 你的朋友可以更容易地为你的项目做贡献(或者拉取最新的变更)</p>
<p>现在用网站来对远程仓库进行可视化操作变得越发流行了(像 GitHub), 但远程仓库永远是这些工具的顶梁柱, 因此理解其概念非常的重要!</p>
<p>直到现在, 教程都聚焦于本地仓库的操作（branch、merge、rebase 等等）。但我们现在需要学习远程仓库的操作 —— 我们需要一个配置这种环境的命令, 它就是 git clone。 从技术上来讲，git clone 命令在真实的环境下的作用是在本地创建一个远程仓库的拷贝（比如从 github.com）。</p>
<h3 id="远程分支"><a href="#远程分支" class="headerlink" title="远程分支"></a>远程分支</h3><p>远程分支反映了远程仓库(在你上次和它通信时)的状态。这会有助于你理解本地的工作与公共工作的差别 —— 这是你与别人分享工作成果前至关重要的一步.</p>
<p>远程分支有一个特别的属性，在你切换到远程分支时，自动进入分离 HEAD 状态。Git 这么做是出于不能直接在这些分支上进行操作的原因, 你必须在别的地方完成你的工作, （更新了远程分支之后）再用远程分享你的工作成果。</p>
<p>你可能想问这些远程分支的前面的 o&#x2F; 是什么意思呢？好吧, 远程分支有一个命名规范 —— 它们的格式是:</p>
<p>&lt; remote name &gt;&#x2F;&lt; branch name &gt;<br>因此，如果你看到一个名为 o&#x2F;main 的分支，那么这个分支就叫 main，远程仓库的名称就是 o。</p>
<p>大多数的开发人员会将它们主要的远程仓库命名为 origin，并不是 o。这是因为当你用 git clone 某个仓库时，Git 已经帮你把远程仓库的名称设置为 origin 了</p>
<p>不过 origin 对于我们的 UI 来说太长了，因此不得不使用简写 o :) 但是要记住, 当你使用真正的 Git 时, 你的远程仓库默认为 origin!</p>
<h3 id="Git-Fetch"><a href="#Git-Fetch" class="headerlink" title="Git Fetch"></a>Git Fetch</h3><p>Git 远程仓库相当的操作实际可以归纳为两点：向远程仓库传输数据以及从远程仓库获取数据。既然我们能与远程仓库同步，那么就可以分享任何能被 Git 管理的更新（因此可以分享代码、文件、想法、情书等等）。</p>
<p>本节课我们将学习如何从远程仓库获取数据 —— 命令如其名，它就是 git fetch。</p>
<p>你会看到当我们从远程仓库获取数据时, 远程分支也会更新以反映最新的远程仓库。</p>
<p>git fetch 完成了仅有的但是很重要的两步:</p>
<p>从远程仓库下载本地仓库中缺失的提交记录<br>更新远程分支指针(如 o&#x2F;main)<br>git fetch 实际上将本地仓库中的远程分支更新成了远程仓库相应分支最新的状态。</p>
<p>如果你还记得上一节课程中我们说过的，远程分支反映了远程仓库在你最后一次与它通信时的状态，git fetch 就是你与远程仓库通信的方式了！希望我说的够明白了，你已经了解 git fetch 与远程分支之间的关系了吧。</p>
<p>git fetch 通常通过互联网（使用 http:&#x2F;&#x2F; 或 git:&#x2F;&#x2F; 协议) 与远程仓库通信。</p>
<p>git fetch 不会做的事<br>git fetch 并不会改变你本地仓库的状态。它不会更新你的 main 分支，也不会修改你磁盘上的文件。</p>
<p>理解这一点很重要，因为许多开发人员误以为执行了 git fetch 以后，他们本地仓库就与远程仓库同步了。它可能已经将进行这一操作所需的所有数据都下载了下来，但是并没有修改你本地的文件。我们在后面的课程中将会讲解能完成该操作的命令 :D</p>
<p>所以, 你可以将 git fetch 的理解为单纯的下载操作。</p>
<h3 id="Git-Pull"><a href="#Git-Pull" class="headerlink" title="Git Pull"></a>Git Pull</h3><p>既然我们已经知道了如何用 git fetch 获取远程的数据, 现在我们学习如何将这些变化更新到我们的工作当中。</p>
<p>其实有很多方法的 —— 当远程分支中有新的提交时，你可以像合并本地分支那样来合并远程分支。也就是说就是你可以执行以下命令:</p>
<p>git cherry-pick o&#x2F;main<br>git rebase o&#x2F;main<br>git merge o&#x2F;main<br>等等<br>实际上，由于先抓取更新再合并到本地分支这个流程很常用，因此 Git 提供了一个专门的命令来完成这两个操作。它就是我们要讲的 git pull。</p>
<p>git pull 就是 git fetch 和 git merge 的缩写！，这里非常的精辟。</p>
<h3 id="模拟团队合作"><a href="#模拟团队合作" class="headerlink" title="模拟团队合作"></a>模拟团队合作</h3><p>这里作者开发了一个全新的命令git fakeTeamWork用来模拟远程仓库的变化</p>
<h3 id="Git-Push"><a href="#Git-Push" class="headerlink" title="Git Push"></a>Git Push</h3><p>OK，我们已经学过了如何从远程仓库获取更新并合并到本地的分支当中。这非常棒……但是我如何与大家分享我的成果呢？</p>
<p>嗯，上传自己分享内容与下载他人的分享刚好相反，那与 git pull 相反的命令是什么呢？git push！</p>
<p>git push 负责将你的变更上传到指定的远程仓库，并在远程仓库上合并你的新提交记录。一旦 git push 完成, 你的朋友们就可以从这个远程仓库下载你分享的成果了！</p>
<p>你可以将 git push 想象成发布你成果的命令。它有许多应用技巧，稍后我们会了解到，但是咱们还是先从基础的开始吧……</p>
<p>注意 —— git push 不带任何参数时的行为与 Git 的一个名为 push.default 的配置有关。它的默认值取决于你正使用的 Git 的版本，但是在教程中我们使用的是 upstream。 这没什么太大的影响，但是在你的项目中进行推送之前，最好检查一下这个配置。</p>
<h3 id="偏离的工作"><a href="#偏离的工作" class="headerlink" title="偏离的工作"></a>偏离的工作</h3><p>现在我们已经知道了如何从其它地方 pull 提交记录，以及如何 push 我们自己的变更。看起来似乎没什么难度，但是为何还会让人们如此困惑呢？</p>
<p>困难来自于远程库提交历史的偏离。</p>
<p>假设你周一克隆了一个仓库，然后开始研发某个新功能。到周五时，你新功能开发测试完毕，可以发布了。但是 —— 天啊！你的同事这周写了一堆代码，还改了许多你的功能中使用的 API，这些变动会导致你新开发的功能变得不可用。但是他们已经将那些提交推送到远程仓库了，因此你的工作就变成了基于项目旧版的代码，与远程仓库最新的代码不匹配了。</p>
<p>这种情况下, git push 就不知道该如何操作了。如果你执行 git push，Git 应该让远程仓库回到星期一那天的状态吗？还是直接在新代码的基础上添加你的代码，亦或由于你的提交已经过时而直接忽略你的提交？</p>
<p>因为这情况（历史偏离）有许多的不确定性，Git 是不会允许你 push 变更的。实际上它会强制你先合并远程最新的代码，然后才能分享你的工作。</p>
<p>那该如何解决这个问题呢？很简单，你需要做的就是使你的工作基于最新的远程分支。</p>
<p>有许多方法做到这一点呢，不过最直接的方法就是通过 rebase 调整你的工作。咱们继续，看看怎么 rebase！</p>
<p>我们用 git fetch 更新了本地仓库中的远程分支，然后用 rebase 将我们的工作移动到最新的提交记录下，最后再用 git push 推送到远程仓库。</p>
<p>还有其它的方法可以在远程仓库变更了以后更新我的工作吗? 当然有，我们还可以使用 merge</p>
<p>尽管 git merge 不会移动你的工作（它会创建新的合并提交），但是它会告诉 Git 你已经合并了远程仓库的所有变更。这是因为远程分支现在是你本地分支的祖先，也就是说你的提交已经包含了远程分支的所有变化。</p>
<p>我们用 git fetch 更新了本地仓库中的远程分支，然后合并了新变更到我们的本地分支（为了包含远程仓库的变更），最后我们用 git push 把工作推送到远程仓库</p>
<p>简化以上两种操作：<br>很好！但是要敲那么多命令，有没有更简单一点的？</p>
<p>当然 —— 前面已经介绍过 git pull 就是 fetch 和 merge 的简写，类似的 git pull –rebase 就是 fetch 和 rebase 的简写！</p>
<h3 id="远程服务器拒绝-Remote-Rejected"><a href="#远程服务器拒绝-Remote-Rejected" class="headerlink" title="远程服务器拒绝!(Remote Rejected)"></a>远程服务器拒绝!(Remote Rejected)</h3><p>如果你是在一个大的合作团队中工作, 很可能是main被锁定了, 需要一些Pull Request流程来合并修改。如果你直接提交(commit)到本地main, 然后试图推送(push)修改, 你将会收到这样类似的信息:</p>
<p>! [远程服务器拒绝] main -&gt; main (TF402455: 不允许推送(push)这个分支; 你必须使用pull request来更新这个分支.)<br>为什么会被拒绝?<br>远程服务器拒绝直接推送(push)提交到main, 因为策略配置要求 pull requests 来提交更新.</p>
<p>你应该按照流程,新建一个分支, 推送(push)这个分支并申请pull request,但是你忘记并直接提交给了main.现在你卡住并且无法推送你的更新.</p>
<p>解决办法<br>新建一个分支feature, 推送到远程服务器. 然后reset你的main分支和远程服务器保持一致, 否则下次你pull并且他人的提交和你冲突的时候就会有问题.</p>
<h2 id="git远程仓库高级操作"><a href="#git远程仓库高级操作" class="headerlink" title="git远程仓库高级操作"></a>git远程仓库高级操作</h2><h3 id="合并特性分支"><a href="#合并特性分支" class="headerlink" title="合并特性分支"></a>合并特性分支</h3><p>在大型项目中开发人员通常会在（从 main 上分出来的）特性分支上工作，工作完成后只做一次集成。这跟前面课程的描述很相像（把 side 分支推送到远程仓库），不过本节我们会深入一些.</p>
<p>但是有些开发人员只在 main 上做 push、pull —— 这样的话 main 总是最新的，始终与远程分支 (o&#x2F;main) 保持一致。</p>
<h3 id="为什么不用-merge-呢"><a href="#为什么不用-merge-呢" class="headerlink" title="为什么不用 merge 呢?"></a>为什么不用 merge 呢?</h3><p>为了 push 新变更到远程仓库，你要做的就是包含远程仓库中最新变更。意思就是只要你的本地分支包含了远程分支（如 o&#x2F;main）中的最新变更就可以了，至于具体是用 rebase 还是 merge，并没有限制。</p>
<p>那么既然没有规定限制，为何前面几节都在着重于 rebase 呢？为什么在操作远程分支时不喜欢用 merge 呢？</p>
<p>在开发社区里，有许多关于 merge 与 rebase 的讨论。以下是关于 rebase 的优缺点：</p>
<p>优点:</p>
<p>Rebase 使你的提交树变得很干净, 所有的提交都在一条线上<br>缺点:</p>
<p>Rebase 修改了提交树的历史<br>比如, 提交 C1 可以被 rebase 到 C3 之后。这看起来 C1 中的工作是在 C3 之后进行的，但实际上是在 C3 之前。</p>
<p>一些开发人员喜欢保留提交历史，因此更偏爱 merge。而其他人（比如我自己）可能更喜欢干净的提交树，于是偏爱 rebase。仁者见仁，智者见智。</p>
<h3 id="远程跟踪分支"><a href="#远程跟踪分支" class="headerlink" title="远程跟踪分支"></a>远程跟踪分支</h3><p>在前几节课程中有件事儿挺神奇的，Git 好像知道 main 与 o&#x2F;main 是相关的。当然这些分支的名字是相似的，可能会让你觉得是依此将远程分支 main 和本地的 main 分支进行了关联。这种关联在以下两种情况下可以清楚地得到展示：</p>
<p>pull 操作时, 提交记录会被先下载到 o&#x2F;main 上，之后再合并到本地的 main 分支。隐含的合并目标由这个关联确定的。<br>push 操作时, 我们把工作从 main 推到远程仓库中的 main 分支(同时会更新远程分支 o&#x2F;main) 。这个推送的目的地也是由这种关联确定的！</p>
<p>直接了当地讲，main 和 o&#x2F;main 的关联关系就是由分支的“remote tracking”属性决定的。main 被设定为跟踪 o&#x2F;main —— 这意味着为 main 分支指定了推送的目的地以及拉取后合并的目标。</p>
<p>你可能想知道 main 分支上这个属性是怎么被设定的，你并没有用任何命令指定过这个属性呀！好吧, 当你克隆仓库的时候, Git 就自动帮你把这个属性设置好了。</p>
<p>当你克隆时, Git 会为远程仓库中的每个分支在本地仓库中创建一个远程分支（比如 o&#x2F;main）。然后再创建一个跟踪远程仓库中活动分支的本地分支，默认情况下这个本地分支会被命名为 main。</p>
<p>克隆完成后，你会得到一个本地分支（如果没有这个本地分支的话，你的目录就是“空白”的），但是可以查看远程仓库中所有的分支（如果你好奇心很强的话）。这样做对于本地仓库和远程仓库来说，都是最佳选择。</p>
<p>这也解释了为什么会在克隆的时候会看到下面的输出：</p>
<p>local branch “main” set to track remote branch “o&#x2F;main”</p>
<p>我能自己指定这个属性吗？<br>当然可以啦！你可以让任意分支跟踪 o&#x2F;main, 然后该分支会像 main 分支一样得到隐含的 push 目的地以及 merge 的目标。 这意味着你可以在分支 totallyNotMain 上执行 git push，将工作推送到远程仓库的 main 分支上。</p>
<p>有两种方法设置这个属性，第一种就是通过远程分支切换到一个新的分支，执行:</p>
<p>git checkout -b totallyNotMain o&#x2F;main</p>
<p>就可以创建一个名为 totallyNotMain 的分支，它跟踪远程分支 o&#x2F;main。</p>
<p>第二种方法<br>另一种设置远程追踪分支的方法就是使用：git branch -u 命令，执行：</p>
<p>git branch -u o&#x2F;main foo</p>
<p>这样 foo 就会跟踪 o&#x2F;main 了。如果当前就在 foo 分支上, 还可以省略 foo：</p>
<p>git branch -u o&#x2F;main</p>
<h3 id="Git-Push-的参数"><a href="#Git-Push-的参数" class="headerlink" title="Git Push 的参数"></a>Git Push 的参数</h3><p>既然你知道了远程跟踪分支，我们可以开始揭开 git push、fetch 和 pull 的神秘面纱了。我们会逐个介绍这几个命令，它们在理念上是非常相似的。</p>
<p>首先来看 git push。在远程跟踪课程中，你已经学到了 Git 是通过当前所在分支的属性来确定远程仓库以及要 push 的目的地的。这是未指定参数时的行为，我们可以为 push 指定参数，语法是：</p>
<p>git push &lt; remote &gt; &lt; place &gt;</p>
<p>&lt; place &gt; 参数是什么意思呢？我们稍后会深入其中的细节, 先看看例子, 这个命令是:</p>
<p>git push origin main</p>
<p>把这个命令翻译过来就是：</p>
<p>切到本地仓库中的“main”分支，获取所有的提交，再到远程仓库“origin”中找到“main”分支，将远程仓库中没有的提交记录都添加上去，搞定之后告诉我。</p>
<p>我们通过“place”参数来告诉 Git 提交记录来自于 main, 要推送到远程仓库中的 main。它实际就是要同步的两个仓库的位置。</p>
<p>需要注意的是，因为我们通过指定参数告诉了 Git 所有它需要的信息, 所以它就忽略了我们所切换分支的属性！</p>
<h3 id="Git-Push-的参数2"><a href="#Git-Push-的参数2" class="headerlink" title="Git Push 的参数2"></a>Git Push 的参数2</h3><p>&lt; place &gt;参数详解<br>还记得之前课程说的吧，当为 git push 指定 place 参数为 main 时，我们同时指定了提交记录的来源和去向。</p>
<p>你可能想问 —— 如果来源和去向分支的名称不同呢？比如你想把本地的 foo 分支推送到远程仓库中的 bar 分支。</p>
<p>哎，很遗憾 Git 做不到…… 开个玩笑，别当真！当然是可以的啦 :) Git 拥有超强的灵活性（有点过于灵活了）</p>
<p>要同时为源和目的地指定 &lt; place &gt; 的话，只需要用冒号 : 将二者连起来就可以了：</p>
<p>git push origin &lt; source &gt;:&lt; destination &gt;</p>
<p>这个参数实际的值是个 refspec，“refspec” 是一个自造的词，意思是 Git 能识别的位置（比如分支 foo 或者 HEAD~1）</p>
<p>一旦你指定了独立的来源和目的地，就可以组织出言简意赅的远程操作命令了.</p>
<p>如果你要推送到的目的分支不存在会怎么样呢？没问题！Git 会在远程仓库中根据你提供的名称帮你创建这个分支！</p>
<h3 id="Git-fetch-的参数"><a href="#Git-fetch-的参数" class="headerlink" title="Git fetch 的参数"></a>Git fetch 的参数</h3><p>我们刚学习了 git push 的参数，很酷的 &lt; place&gt; 参数，还有用冒号分隔的 refspecs（&lt; source &gt;:&lt; destination &gt;）。 这些参数可以用于 git fetch 吗？</p>
<p>你猜中了！git fetch 的参数和 git push 极其相似。他们的概念是相同的，只是方向相反罢了（因为现在你是下载，而非上传）</p>
<p>&lt; place &gt; 参数<br>如果你像如下命令这样为 git fetch 设置 的话：</p>
<p>git fetch origin foo</p>
<p>Git 会到远程仓库的 foo 分支上，然后获取所有本地不存在的提交，放到本地的 o&#x2F;foo 上。</p>
<p>你可能会好奇 —— 为何 Git 会将新提交放到 o&#x2F;foo 而不是放到我本地的 foo 分支呢？之前不是说这样的 参数就是同时应用于本地和远程的位置吗？</p>
<p>好吧, 本例中 Git 做了一些特殊处理，因为你可能在 foo 分支上的工作还未完成，你也不想弄乱它。还记得在 git fetch 课程里我们讲到的吗 —— 它不会更新你的本地的非远程分支, 只是下载提交记录（这样, 你就可以对远程分支进行检查或者合并了）。</p>
<p>“如果我们指定 &lt; source &gt;:&lt; destination &gt; 会发生什么呢？”</p>
<p>如果你觉得直接更新本地分支很爽，那你就用冒号分隔的 refspec 吧。不过，你不能在当前切换的分支上干这个事，但是其它分支是可以的。</p>
<p>这里有一点是需要注意的 —— source 现在指的是远程仓库中的位置，而 &lt; destination &gt; 才是要放置提交的本地仓库的位置。它与 git push 刚好相反，这是可以讲的通的，因为我们在往相反的方向传送数据。</p>
<p>理论上虽然行的通，但开发人员很少这么做。我在这里介绍它主要是为了从概念上说明 fetch 和 push 的相似性，只是方向相反罢了。</p>
<p>跟 git push 一样，Git 会在 fetch 前自己创建立本地分支, 就像是 Git 在 push 时，如果远程仓库中不存在目标分支，会自己在建立一样。</p>
<h3 id="古怪的-lt-source-gt"><a href="#古怪的-lt-source-gt" class="headerlink" title="古怪的 &lt; source &gt;"></a>古怪的 &lt; source &gt;</h3><p>Git 有两种关于 &lt; source &gt; 的用法是比较诡异的，即你可以在 git push 或 git fetch 时不指定任何 source，方法就是仅保留冒号和 destination 部分，source 部分留空。</p>
<p>git push origin :side，它会删除远程仓库中的分支！<br>git fetch origin :bugFix，如果 fetch 空 到本地，会在本地创建一个新分支。</p>
<h3 id="Git-pull-参数"><a href="#Git-pull-参数" class="headerlink" title="Git pull 参数"></a>Git pull 参数</h3><p>既然你已经掌握关于 git fetch 和 git push 参数的方方面面了，关于 git pull 几乎没有什么可以讲的了 :)</p>
<p>因为 git pull 到头来就是 fetch 后跟 merge 的缩写。你可以理解为用同样的参数执行 git fetch，然后再 merge 你所抓取到的提交记录。</p>
<p>以下命令在 Git 中是等效的:</p>
<p>git pull origin foo 相当于：</p>
<p>git fetch origin foo; git merge o&#x2F;foo</p>
<p>还有…</p>
<p>git pull origin bar~1:bugFix 相当于：</p>
<p>git fetch origin bar~1:bugFix; git merge bugFix</p>
<p>看到了? git pull 实际上就是 fetch + merge 的缩写, git pull 唯一关注的是提交最终合并到哪里（也就是为 git fetch 所提供的 destination 参数）</p>
]]></content>
      <categories>
        <category>编程学习笔记</category>
      </categories>
      <tags>
        <tag>完结</tag>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>算法导论阅读笔记</title>
    <url>/2023/08/27/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>大一的时候买的书，一直说以后看，以后看，这一推就到了现在，不能再推下去了。<br>现在开始啃这本书，可以说我是抱着巨大的勇气进行的，特别决定了还要发到博客当中去监督自己的这一决心。<br>所以这个系列在表述的过程当中可能会有误，希望有大佬看到错误的地方可以私发我邮件，或则评论区指出，无论有多尖锐都请您随意发出，不用客气的批评我，这里再次表达感激之情。<br>现在让我开始啃这个巨著吧，争取做到日更。</p>
<h1 id="第一部分-基础知识"><a href="#第一部分-基础知识" class="headerlink" title="第一部分 基础知识"></a>第一部分 基础知识</h1><h2 id="第1章-算法在计算中的作用"><a href="#第1章-算法在计算中的作用" class="headerlink" title="第1章 算法在计算中的作用"></a>第1章 算法在计算中的作用</h2><h3 id="1-1-算法"><a href="#1-1-算法" class="headerlink" title="1.1 算法"></a>1.1 算法</h3><p>算法就是任何良定义的计算过程，也可以看作是用于求解良说明的计算问题的工具。<br>良定义包含四个方面：明确性，有限性，输入和输出，可行性。<br>良说明包含五个方面：输入， 输出，约束条件，问题的性质，示例。</p>
<p>许多有趣算法问题所共有的两个特征：<br>1.存在许多候选解<br>2.存在实际应用<br>候选解指的是：候选解是指在解决问题或完成任务时，被认为可能是正确或有效解决方案的一个潜在选择。</p>
<p>NP完全的问题需要满足两个条件：<br>1.可证明性<br>2.NP难度</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">举例子：想象你在玩一个拼图游戏，你得到了一些拼图块，而且你需要将它们组合成一个完整的拼图。如果你把所有的拼图块正确地组合在一起，你可以很容易地看到结果是正确的。这就是“可证明性”，因为你可以验证最终拼图是否正确。    </span><br><span class="line">现在，假设你没有完整的拼图图像，而是零散地得到一块块拼图，然后需要找到一个方法将它们组合起来。NP-完全问题就类似于这种情况。它们要求你找到一个解，就像是将零散的拼图块组合在一起，以满足某些条件。这些问题很难，因为找到这种解看起来并不容易。   </span><br><span class="line">但是，如果你告诉别人你已经找到了一个可能的拼图组合方式，别人可以很快地验证它是否正确。这就是问题的“可证明性”。NP-完全问题的关键在于，如果你能够在快速的时间内验证一个可能的解，那么理论上你也可以在快速的时间内找到一个解。这就是为什么这些问题被认为是非常困难的，因为目前我们没有找到一种快速的方法来解决它们，但如果我们找到了一个解，我们可以快速地验证它是否正确。</span><br></pre></td></tr></table></figure>

<p>练习:<br>1.1-1     </p>
<h3 id="1-2-作为一种技术的算法"><a href="#1-2-作为一种技术的算法" class="headerlink" title="1.2 作为一种技术的算法"></a>1.2 作为一种技术的算法</h3>]]></content>
      <categories>
        <category>编程学习笔记</category>
      </categories>
      <tags>
        <tag>算法导论</tag>
        <tag>阅读笔记</tag>
        <tag>搁置</tag>
      </tags>
  </entry>
  <entry>
    <title>日常一些碎碎念</title>
    <url>/2023/08/28/%E6%97%A5%E5%B8%B8%E4%B8%80%E4%BA%9B%E7%A2%8E%E7%A2%8E%E5%BF%B5/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>记录平时的一些碎碎念，当时所想只是一种情感，一种激情，可能并不正确，但对这些情感的快照，留存于此，对我而言，弥足珍贵。<br>因为本博客，还是以IT技术为主，所以这类信息就全部存放在此，以保证博客的简洁。<br>记录的碎碎念，按栈的理论，先进后出，也就是时间倒序的排列。<br>下面是正文。</p>
<span id="more"></span>
<h1 id="正文（时间倒序排列）"><a href="#正文（时间倒序排列）" class="headerlink" title="正文（时间倒序排列）"></a>正文（时间倒序排列）</h1><h2 id="自学之路的感悟"><a href="#自学之路的感悟" class="headerlink" title="自学之路的感悟"></a>自学之路的感悟</h2><p>自学就是从0到1的突破，因为是主动突击，比起以往有的百分之百的可能，如果没有看到这种可能性的话，那么一个人的自学之路就会就此夭折，需要非常明白的一点是，选择这种自主的权力一直是非常奢侈的的一种权利，在此之上衍生出来的人生的自由是非常奢侈的。绝对的自由就代表绝对的负责，你不受以往教条的约束，困难会一个一个的浮现，你只能做一个勇士，去为你的选择去负责，自主意味的全责，你将无所遁避，你将直面问题，你将回答问题，你将只有胜利，你将充满煎熬，你将自我完善。</p>
<h2 id="数据的重视"><a href="#数据的重视" class="headerlink" title="数据的重视"></a>数据的重视</h2><p>现在人们通常重视物质基础，感情精神世界，却没有明确对于数据的重视，数据是身边事物的科学的映射，通过数据我们来了解世界，这些数据汇集的本身就是一个智慧，一种财富，许多人对于外在的事物狂热追求，却没有看看自己身边的数据。<br>我举例一个简单的例子：你可以给你今天的生活质量打分，如果前进了有进步是1，如果没有是停滞的是0，如果是后退的是-1，如果把日历的每一天置换成这样的数据累加就可以知道你这一个月的生活自主状态，如果累加的一年，可以看出你一年的状态综合。<br>我们玩游戏，很大程度上玩的就是这些具体的数据，这些具体数据的跳动，会给予我们多巴胺的性奋，这是我们的本能。可能我们不是很精准了解数据，但是我们的直觉会感觉到数据的明显变化，我希望我们能多一点科学的态度在日常的生活当中，因为只有了解数据，重视科学，才能够活得不至于太迷茫，它们仅仅是一种参考，并没有夺舍你的情感。<br>科学无法成为人们心中的支撑，它仅仅只能提供方式，而对数据的重视，本质上是对推动我们发展的科学的重视。</p>
<h2 id="无知插进Matrix的利剑"><a href="#无知插进Matrix的利剑" class="headerlink" title="无知插进Matrix的利剑"></a>无知插进Matrix的利剑</h2><p>我们通常可以审视别人，却难以审视自己，因此感到迷茫无助，缺失自我。<br>从根本上承认自己的无知，才可以认识自己，并给予宽限。<br>去读书，感受不同人对不同事物的不同看法。<br>去行动，感受从名到实的实现过程。<br>去怀疑，无知不仅限于自己，也同样适用于他人。<br>它是利剑，是给勇敢者面对生活的最好的赞歌，有怯弱才会勇敢，有无知才有智慧。</p>
<h2 id="螺旋，锚，切片的图景"><a href="#螺旋，锚，切片的图景" class="headerlink" title="螺旋，锚，切片的图景"></a>螺旋，锚，切片的图景</h2><p>图景的样貌：<br>这是一副中间宽两头尖的不停旋转的铁质螺旋，闪的银白色的光泽，在不停旋转的当中，有的各种个样的小点组成，它是一个又一个的锚，随着铁质螺旋的旋转而旋转。<br>旋转有快有慢，如果突然把时间暂停，它就是一个又一个的贴片，预示的来和往。<br>图景的启示：<br>锚是位置，旋转的螺旋是趋势，锚可以不动也可以动，预示的两层含义，动则符合趋势，不动则不合趋势。切片是二者具体的来和往，可以拨动时间前进，也可以拨动时间后退。<br>图景的方法：<br>通过当前存在的实，可以倒推后续的发展，也可以根据现在的实，倒推过去的由来的名。自己身中所处的位置，在存在的趋势面前，如果不随之变化而变化，就会被裹挟，动或则不动，自己都在其中，拨动时间的拨片，可以根据切片来查询具体的锚的名或实的关系。<br>实际的操作：<br>指定一个目标的计划，可以把进度二分，再二分，再二分，分到今天为止的递归。今天完成的计划的结果，可以推导乘以二，乘以二，直到具体目标的实现。<br>现实的观察：<br>可以的念头，会有假设的结果，如果随之而动，会有符合名的实发生。已经发生的实，可以嗅到其中的名，来探知过往的实。</p>
<h2 id="使用番茄时钟的意义"><a href="#使用番茄时钟的意义" class="headerlink" title="使用番茄时钟的意义"></a>使用番茄时钟的意义</h2><p>番茄时钟旨在帮助计划能够顺利进行，但是我常遇到这样的情况，就是我爽的飞起干这件事，番茄时钟却要求你停下休息，以为了能够跑得更久。这种想法在很多的娱乐产品，如大型的单机游戏，跌宕起伏的电影，都需要这种，休息，冲刺，休息，冲刺。包括健身，都会按组来做锻炼，而不会一直疯狂做。<br>这些想法非常好，但是无法解释，为什么我可以玩游戏一整天而不累，真的在休息的途中，我没有玩么？不，我一直玩，我从早上玩到晚上。这里的变量是兴趣，我们需要的是番茄时钟干不喜欢的事情。只有干不喜欢的事情我们才会渴望休息。如果这个事情你无比喜欢，你是不会考虑休息，你会进入心流，这是休息反而是一种坏处，一种干扰，一种必须被抛弃的概念。<br>所以使用番茄时钟进入佳境，就应该丢掉它，它会影响我们进入最里面的深度。除非你不喜欢，需要来个大长跑，实际上，自己可以感觉到自己的疲劳，这个时候，需要的是一杯咖啡，继续前伸，然后不行，我们休息总结。<br>一次深入的交流，好过多次表面功夫，这样可以更顺利的帮助计划的进行。</p>
<h2 id="终结，起始，当下"><a href="#终结，起始，当下" class="headerlink" title="终结，起始，当下"></a>终结，起始，当下</h2><p>终结所有一切的思绪，沉浸在当下，沉浸在此时的快乐，是无负担，开心的享受。<br>人需先自爱，方可教人爱你，当下，就是自爱的体现。<br>宗教徒的祷告，之所以充满力量温暖人心，是在无上之高的交流当中感受到了宁静，心灵归属了寄托。<br>所以爱上帝和爱自己统一，信教者往往快乐充实。<br>然而自己也有这本能的力量，就是沉浸于当下，沉浸于当下需要首先终结起始的意识，起始的意识，是待发动的意思。<br>只有无意识于当下，就是对内心的祷告。是内心的平静和安宁。<br>这是一种有品质的生活态度，有品质的评价是对自爱的体现。<br>是自爱在我身上的衍生，人们寻觅太多，而常常缺视自身，这并不平衡。</p>
<h2 id="静坐于呼吸当中的两极体悟"><a href="#静坐于呼吸当中的两极体悟" class="headerlink" title="静坐于呼吸当中的两极体悟"></a>静坐于呼吸当中的两极体悟</h2><p>烦躁，焦虑，悲伤，自傲，疲惫，等等负面情绪，通过静坐可以得到充分的缓解，因为静坐在安静的环境之下，清净了五官，缓解了四肢。我在静坐当中不仅可以感受到呼吸的频率，还可以感受到心脏的跳动，伴随的心脏的跳动，内部蹦蹦的活力。全身心沉浸在安谧，就会感觉到两极的变化，比如骄傲，就要谦虚，比如焦虑，就要放松，比如悲伤，就要乐观，比如烦躁，就要平静。周身的中正，内心的中正，奇妙，奇妙。</p>
<h2 id="成长的可行性"><a href="#成长的可行性" class="headerlink" title="成长的可行性"></a>成长的可行性</h2><p>成长是否是会在一瞬间停止，成长又会在那一刻生长？这取决于名的概念。如果是因为外在环境的变化，那么成长也会发生，但那只是表象的变化，是实对名。就其本身而言，本我的名从来没有考究过自己的成长，属于阶段性的适应性成长，是会在适应的环境的磨合期当中停止成长，这个人就会保留在此之前的全部。在意识层面的名上已经暂停生长，成为了一个僵硬的人，一个封闭的人。我所指的成长可行性是意识层面成长，是内心的成长，这种成长不是适应环境的被动成长。是一种主动的有所指向的成长，而在这过程当中，绝大部分人都忽视了成长的可行性这个方面。<br>自我的成长固然重要，但是不对环境，终究还是回归环境，成长的过程要和成长的可行性等长，两种应该是一种交互的方式，只要有成长的可行性这个方向的指引，成长就会在它的环境的空间内生长。对此苏格拉底有很深的感悟，他说过“我是智慧的接生者”这句话就点名了这一点。成长对于个人是不一样的意义，哪怕苏格拉底都喜欢和不同人交谈，对他而言，他的弟子而言，这是一种获得智慧的方式。通过交流介入别人成长可行性来指导成长本身的过程，是互相交互共同成就成长的过程。<br>在一个可行性的指引下，成长会缓慢发生，他将引导人往变化的方向的发展，至于好或者坏的结果，我们无法预言，能知道的是这条路可以继续走，最怕的是走无可走，那就意味着的成长可行性的凋亡，自身的固定，自身的僵化，是自我对现状的满足，成长也就再次回归到他字面上的意义，从个人的名当中剔去了，也变成我们平常的语言。成长和长大两个词语，你若不仔细看将再你身上没有任何差别，你就将就此成为你。</p>
<h2 id="完美存在于概念"><a href="#完美存在于概念" class="headerlink" title="完美存在于概念"></a>完美存在于概念</h2><p>完美是存在的，但是它不存在于实际之中，也就是说没有完美的物品，因为完美没有标准，完美引向了全知全能的趋势。如果一个事物完美，其实它并不完美，它只是达标而已，因为达到预期及其以上的程度所以称为完美，其实是很不错的主观判断。而完美一词具有迷惑性，它和主观的判断有着某种割裂，仿佛脱离了判断这个完美的人还是完美的一样。那它就不完美了，所以完美是存在于概念当中的事物，现实事物的评价，只有标准的符合的程度。而没有完美这个没有刻度的主观评价的属性的存在。完美只有个体的惊叹，而没有事物的准确的描述。<br>如果有如实描述完美，就有说出标准，没有说出标准的完美而称为完美，是他人的主观完美转移到了事物之上，被人赋予的完美。人人觉得完美的事物，归根到底还是事物本身，事物本身是会变化，如果这样来看完美更是一种暂时性质的快照。更反映出符合一个标准之上的预期判断，可能自己都没有意识到自知的标准，就称呼其为完美。<br>所以了解完美的事物，就是了解赋予完美事物的人的观念。完美只存在于概念之中，是一个个体那瞬间的惊叹。</p>
<h2 id="简略思考到行动"><a href="#简略思考到行动" class="headerlink" title="简略思考到行动"></a>简略思考到行动</h2><p>过度的思考反思到事物的名当中是一个费神的功夫，这一过程通常没有确切的目的和诉求，是其本身发散的组合，所以快速的思考，缓慢的拼凑可能性，但是没有终止的条件。因为这一过程的本质是追求最优解。而如果沉迷于其中往往得不偿失，空耗精神而无所得，会顾此失彼。<br>因此为了简略的思考，快乐的生活，需要简化这一思考的流程。需要得出能够实践的结论，应该率先提炼出来，然后就到终止条件，可以提前跳出这一不断完善的过程了。空空耗神的时间也是实践过程的成本，这不可估量。<br>需要的路可能不是最优美的一条，但是胜在可以走的更远，这一前提会让人变得更加的果敢一些。可以很快的得出结论，然后行动，创造突破口，添加筹码，迅速迭代，从而更加切合实际，毕竟名不能太过高于实了，那就变成了痴人说梦。</p>
<h2 id="语言欲演自身"><a href="#语言欲演自身" class="headerlink" title="语言欲演自身"></a>语言欲演自身</h2><p>语言是文化的载体，知道语言就可以知道其内在的力量。<br>语言会影响自身，语言会塑造自身。<br>少说多做，少想多做，少思多做，在行动中把语言转换为力量，语言的背后是潜在的名，未有实现的实在力量。被其影响，就会变成其样。<br>所有人在为受影响之前，应该是白洁污垢之人，有了影响之后，就有了实在当中的所在定位。所有的一切额外附加，在生下来的时候就已经决定。</p>
<h2 id="外在环境是必要的"><a href="#外在环境是必要的" class="headerlink" title="外在环境是必要的"></a>外在环境是必要的</h2><p>虚无者在存在的过程当中，是静止不动的。<br>也就是死寂，但是这个情况属于假的死寂。<br>我理解的真的死寂，应该是和个体一样的精神死亡一样，彻底和外在脱节。<br>而虚无者还和外界是有关联的，所以跟我定义的死寂是差一步之遥。<br>所以我希望可以和英文一样加个ing估计好理解一点，死寂ing。<br>但是在这里，我称作为假的死寂。<br>因为是不完全的死寂，还和外界存在的交互。<br>或多或少会被外在冲击，所以会产生自我和外在的矛盾。这种矛盾的产生就是”非我”的因素，客观的实在在冲击自己。<br>想要精神的绝对自由因此不可能存在，外在的实在始终存在，无法脱离外在而独存，就是一个明证。<br>所以我希望撞到南墙就回头，虚无者应该变成积极者，外在实在就会带你走向另外一个道路。但是如果本身没有过虚无者念头的实现，就没有很清楚的分别”我”和”非我”，因为在现实实际当中，两者是互相包裹的，难以分开。自杀者之所以会选择自我肉体毁灭的想法，就是想试图赶走”非我”的存在，一了百了，是一种抛离的方式，一种取消问题本身的方法。<br>而虚无者比自杀者的高明在于直接对抗这外在的实在，试图分离”我”和”非我”，亦或者是和解”我”和”非我”，所以就会产生这样一个极端的两极反转，从消极的虚无变成积极的虚无，进而会开启全新的视野去看待外在事物，看待”非我”，一睡一醒之间就换了人间。这里之所以用积极的虚无就是说明本质并没有发生改变，发生改变的是因对外在的行为，这里存在的不确定性，只要这个虚无者愿意，他随时可以再一次进行对抗，直到他认可为止。<br>这里让我想到了尼采构想超越人的的全新物种–超人。如何成为超人，可能就有这么一条路径很有可能就是通过这种类似的方式来进行获取的，而语言文字是有其存在的上限，因此无法用语言来完全完整的表述获取的东西，也就是会成为外人看来的另类者或者境界高的人的原因，因为他的本身是发散的太阳，他的道理说不尽道不完，而又因为每一个在成为虚无者之前，他们本身都是不一样的存在，所以他们本身发散的太阳也是互相不一样的。世界上没有两个相同的两片叶子，也没有两个相同的人，我只能成为”我”。</p>
<h2 id="对虚无者凝视虚无的呻吟"><a href="#对虚无者凝视虚无的呻吟" class="headerlink" title="对虚无者凝视虚无的呻吟"></a>对虚无者凝视虚无的呻吟</h2><p>这是一首悲歌，凄惨，黑暗，无助的逝去。<br>没有任何意义是一个毒药，会毒害存在本身。<br>没有意义，空有虚无，唯有永恒。<br>四肢陌生，五官无感，脱离尘世。</p>
<h2 id="“我”的意义"><a href="#“我”的意义" class="headerlink" title="“我”的意义"></a>“我”的意义</h2><p>“我”的概念是凝视出来的产物。<br>如果没有，或者被现代的科技如短视频之类的蒙蔽了”我”。<br>那么没有”我”的人，是被沉沦的对象。<br>如果有了”我”就有了痛苦和快乐，就有了与实在世界的接触。<br>这个接触可以让”我”有血有肉，不要忘记这种感觉，那是”我”在活着。<br>古人和今人相比更加容易保持这种状态，因为它们缺少干扰，就能在”我”的基础上抒发志向，淳淳而行。今人则不同，”我”的缺位，让”我”长期成为沉沦的对象”它”代入有意义或无意义非”我”的主体对象，是主体的错位。这种错位会让人空洞化，标签化，是我非”我”。<br>就我个人体验而言，在我身上比重极大，是”我”长期变成”它”的无力的，快活的，乌托邦似的，空虚的，荒诞的，之其以前孩提就存在而无法描述的感觉，现在得以描述，对我而言是名有所实指，需要时常温习，不能忘”我”。<br>这里反问我一句来凝视自身：“你真心实切的想好你正在成为什么了么？”。</p>
<h2 id="凝视的意义"><a href="#凝视的意义" class="headerlink" title="凝视的意义"></a>凝视的意义</h2><p>凝视是这样到来的，我拥有这样一个图景，一个暗淡的天空笼罩镜面般的湖泊，而我悬浮在湖泊的椅子上看的镜面般的湖泊。<br>在这个意像当中我看到的只有我自己，孤独自处。<br>就会想变得优雅，在无人之中，保持规律。<br>因为对视，所以产生了意图。<br>自我也在此产生。<br>我有了实体，就会凝视别的含义，看向远处。</p>
<h2 id="未来态"><a href="#未来态" class="headerlink" title="未来态"></a>未来态</h2><p>很少感觉到的激情在我沉寂已久心理的迸发出来，这是我继感受名与实的困惑又一次的超越。<br>我觉得未来态，将会出现，这将是我所求的一个生活态度。</p>
<p>未来态是一种创新和变革的未来主义，拥抱他的人将会拥有全新的生活态度。<br>这种生活态度，这种状态，我称之为未来态。<br>以一种全新开放的态度迎接未来生活。<br>第一就是信息的完备，信息是未来态这种生活态度的基石，没有充足的信息，就无法正确的理解事物。<br>第二是理解信息，如果不能够处理繁多的信息，就会提炼不出未来态。<br>第三是建立图景，要便捷的绘画在脑内，在多种感官，在繁多当中找到自己最喜欢的模型，最优美的图案。<br>第四是选择，这将是最煎熬的时刻，意味着你将踏入未来态。<br>第五是理所当然的行动。</p>
<h2 id="名与实的暂叙"><a href="#名与实的暂叙" class="headerlink" title="名与实的暂叙"></a>名与实的暂叙</h2><p>1.名是实的发生<br>2.实是名的依存<br>3.名和实在纵向是起点和终点的图景<br>其中的指引便是对于图景的连接，这是一种超出常人的预示，也只有预示才可以指引现实。<br>4.对于图景的选择：<br>图景的选择是对于信息的压缩。<br>画面的中断是存在的前进，是一种画面的帧。  </p>
]]></content>
      <categories>
        <category>碎碎念</category>
      </categories>
      <tags>
        <tag>碎碎念</tag>
        <tag>哲思随笔</tag>
        <tag>不定时更新</tag>
      </tags>
  </entry>
  <entry>
    <title>基础数据结构的实现和注解</title>
    <url>/2023/09/04/%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%92%8C%E6%B3%A8%E8%A7%A3/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>数据结构的实现是数据结构整体概念的落实，没有这整一个过程的实践，那么具体的思想就没有了归处，这里主要是参考Frank在讲数据结构课程当中写的实现代码，这里只是作为一个学习demo具体实现记录的分享，希望大佬多多指教。</p>
<span id="more"></span>
<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="实现动态数组"><a href="#实现动态数组" class="headerlink" title="实现动态数组"></a>实现动态数组</h2><h3 id="C语言面向过程实现"><a href="#C语言面向过程实现" class="headerlink" title="C语言面向过程实现"></a>C语言面向过程实现</h3><h3 id="Java语言面向对象实现"><a href="#Java语言面向对象实现" class="headerlink" title="Java语言面向对象实现"></a>Java语言面向对象实现</h3>]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>编程学习笔记</tag>
        <tag>更新中</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>《猴子都能懂的Git入门》学习笔记</title>
    <url>/2023/08/28/%E3%80%8A%E7%8C%B4%E5%AD%90%E9%83%BD%E8%83%BD%E6%87%82%E7%9A%84Git%E5%85%A5%E9%97%A8%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="首先"><a href="#首先" class="headerlink" title="首先"></a>首先</h2><p>Git是一个分布式版本管理系统，是为了更好地管理Linux内核开发而创立的。<br>用Git管理文件，更新的历史会保存在Git。<br>如果和别人共享文件修改时有冲突，会发出报错警告。  </p>
<span id="more"></span>
<h2 id="Git的数据库"><a href="#Git的数据库" class="headerlink" title="Git的数据库"></a>Git的数据库</h2><p>数据库 (Repository) 是记录文件或目录状态的地方，存储着内容修改的历史记录。<br>Git的数据库分为远程数据库和本地数据库的两种。<br>远程数据库和本地数据库的交流为pull和push。<br>其中：创建本地数据库的方法有两种：一种是创建全新的数据库，另一种是复制远程数据库。<br>提交到远程数据库为了方便协同合作，务必输入准确简洁的提交信息，遵循下列Git的标准注解原则：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">第1行：提交修改内容的摘要</span><br><span class="line">第2行：空行</span><br><span class="line">第3行以后：修改的理由</span><br></pre></td></tr></table></figure>

<h2 id="工作树和索引"><a href="#工作树和索引" class="headerlink" title="工作树和索引"></a>工作树和索引</h2><p>在Git管理下，大家实际操作的目录被称为工作树。<br>在数据库和工作树之间有索引，索引是为了向数据库提交作准备的区域。<br>凭借中间的索引，可以避免工作树中不必要的文件提交，还可以将文件修改内容的一部分加入索引区域并提交。</p>
<h2 id="实操的提前准备"><a href="#实操的提前准备" class="headerlink" title="实操的提前准备"></a>实操的提前准备</h2><p>首先安装<a href="http://msysgit.github.io/">git</a>，再安装开放源代码的Git客户端<a href="http://code.google.com/p/tortoisegit/">TortoiseGit</a>（有官方汉化语言包）。</p>
<h2 id="版本库，工作树，暂存区"><a href="#版本库，工作树，暂存区" class="headerlink" title="版本库，工作树，暂存区"></a>版本库，工作树，暂存区</h2><p>版本库（Repository）： 在Git中，版本库是存储代码历史记录的地方。它包括了整个项目的历史状态、分支、标签等信息。当你执行git init命令创建一个新的版本库时，Git会在你的项目文件夹中生成一个名为.git的隐藏文件夹，这个文件夹就是版本库。</p>
<p>工作树（Working Tree）： 工作树是你项目文件夹中的实际文件和文件夹，它反映了你当前的工作状态。在工作树中进行的文件修改、添加、删除等操作都会被记录下来，然后可以通过提交到版本库来保留这些修改。</p>
<p>暂存区（Staging Area）： 暂存区是位于版本库和工作树之间的一个缓冲区域。当你使用git add命令将文件添加到暂存区时，你正在告诉Git这些文件将会被包含在下一次的提交中。</p>
<p>在操作过程中，文件会从工作树添加到暂存区，然后再从暂存区提交到版本库中。这种分层结构使得Git能够记录代码的变更历史并支持版本控制。</p>
<h2 id="解决冲突"><a href="#解决冲突" class="headerlink" title="解决冲突"></a>解决冲突</h2><p>当前一个数据和后一个数据冲突，需要对手动来解决冲突，我们首先需要pull，得到远程别人最新的修改版本，到本地来对照自己的版本，解决冲突之后再上传push。</p>
<h2 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h2><p>分支是为了将修改记录的整体流程分叉保存。分叉后的分支不受其他分支的影响，所以在同一个数据库里可以同时进行多个修改。<br>为了不受其他开发人员的影响，您可以在主分支上建立自己专用的分支。完成工作后，将自己分支上的修改合并到主分支。因为每一次提交的历史记录都会被保存，所以当发生问题时，定位和修改造成问题的提交就容易多了。</p>
<h3 id="常见的两种分支形式"><a href="#常见的两种分支形式" class="headerlink" title="常见的两种分支形式"></a>常见的两种分支形式</h3><p>Merge分支是为了可以随时发布release而创建的分支，它还能作为Topic分支的源分支使用。保持分支稳定的状态是很重要的。通常，大家会将master分支当作Merge分支使用。</p>
<p>Topic分支是为了开发新功能或修复Bug等任务而建立的分支。若要同时进行多个的任务，请创建多个的Topic分支。Topic分支是从稳定的Merge分支创建的。完成作业后，要把Topic分支合并回Merge分支。</p>
<h3 id="分支的切换"><a href="#分支的切换" class="headerlink" title="分支的切换"></a>分支的切换</h3><p>若要切换作业的分支，就要进行checkout操作。进行checkout时，git会从工作树还原向目标分支提交的修改内容。checkout之后的提交记录将被追加到目标分支。<br>这里需要注意的是，还原的是git本地的，工作区和暂存区，还原之后，就会把版本库和工作树切换到全新的分支。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git checkout -b branchB #-b的参数是branch的意思</span><br><span class="line">git checkout branchB #这里是切换到branchB，如果没有需要加-b参数，切换并创建</span><br></pre></td></tr></table></figure>

<h3 id="head指针"><a href="#head指针" class="headerlink" title="head指针"></a>head指针</h3><p>涉及到分支的切换，就需要了解head的指针，HEAD指向的是现在使用中的分支的最后一次更新。通常默认指向master分支的最后一次更新。通过移动HEAD，就可以变更使用的分支。</p>
<blockquote>
<p>举一个例子：<br>假设你有一个提交历史记录 A -&gt; B -&gt; C -&gt; D -&gt; E，并且”HEAD” 当前指向 E。</p>
</blockquote>
<blockquote>
<p>如果你想要创建一个新的分支 B2，可以使用 git checkout -b B2 命令。这会在 E 的位置创建一个新分支 B2，然后将”HEAD” 移动到 B2，意味着你在 B2 分支上开始了新的工作。</p>
</blockquote>
<blockquote>
<p>如果你想要将版本回退到 C，你可以使用 git reset –hard C 命令。这将会让”HEAD” 和当前分支都指向 C，你的工作树和暂存区也会被还原为 C 的状态。</p>
</blockquote>
<blockquote>
<p>通过切换分支或回退版本，”HEAD” 会移动到不同的提交位置，指向不同的分支或提交。</p>
</blockquote>
<h3 id="stash操作"><a href="#stash操作" class="headerlink" title="stash操作"></a>stash操作</h3><p>还未提交的修改内容以及新添加的文件，留在索引区域或工作树的情况下切换到其他的分支时，修改内容会从原来的分支移动到目标分支。<br>但是如果在checkout的目标分支中相同的文件也有修改，checkout会失败的。这时要么先提交修改内容，要么用stash暂时保存修改内容后再checkout。<br>stash是临时保存文件修改内容的区域。stash可以暂时保存工作树和索引里还没提交的修改内容，您可以事后再取出暂存的修改，应用到原先的分支或其他的分支上。<br>总结：”stash” 在Git中指的是暂时隐藏未提交修改的操作，使你可以在不提交修改的情况下进行其他操作。</p>
<h2 id="分支的合并"><a href="#分支的合并" class="headerlink" title="分支的合并"></a>分支的合并</h2><p>合并分支有2种方法：使用merge或rebase</p>
<h3 id="merge"><a href="#merge" class="headerlink" title="merge"></a>merge</h3><p>merge合并是将一个分支的更改合并到另一个分支的常见方法。合并创建一个新的提交，将两个分支的更改整合到一起。合并提交将会有多个父提交，分别来自于要合并的两个分支。这种方法适用于保留分支历史，使每个分支的更改都能够清楚地追踪。</p>
<h3 id="rebase"><a href="#rebase" class="headerlink" title="rebase"></a>rebase</h3><p>Rebase变基是另一种将分支更改整合的方法，它的目标是创建一个线性的提交历史，使分支看起来像是连续的。在变基过程中，你从一个分支 “复制” 更改，然后将它们 “粘贴” 到另一个分支的末尾。这使得提交历史看起来更干净，但也可能会改变提交的顺序和提交的 SHA 标识。</p>
<p>总结区别：<br>Merge 会创建一个合并提交，它反映了分支间的合并。<br>Rebase 会将源分支的更改逐个应用到目标分支的末尾，形成一个线性的提交历史。</p>
<h3 id="git分支的应用"><a href="#git分支的应用" class="headerlink" title="git分支的应用"></a>git分支的应用</h3><p>点击查看Vincent Driessen大佬的博文<a href="http://nvie.com/posts/a-successful-git-branching-model/">A successful Git branching model</a><br>阅读原文推荐浏览器插件沙拉查词，或则使用欧路词典eudic。<br>作者在时间的推移当中，划分了五个不同类型的branch。<br>类型1：master，主类型，起label的作用，确定档号，最稳定版。    </p>
<blockquote>
<p>作者原话摘抄：We consider origin&#x2F;master to be the main branch where the source code of HEAD always reflects a production-ready state.  </p>
</blockquote>
<p>类型2：hotfixes，紧急类型，起熬夜加班修bug类型,修完之后需要立刻更新到其他develop和master分支上。   </p>
<blockquote>
<p>Hotfix branches are very much like release branches in that they are also meant to prepare for a new production release, albeit unplanned. They arise from the necessity to act immediately upon an undesired state of a live production version. When a critical bug in a production version must be resolved immediately, a hotfix branch may be branched off from the corresponding tag on the master branch that marks the production version.</p>
</blockquote>
<blockquote>
<p>The one exception to the rule here is that, when a release branch currently exists, the hotfix changes need to be merged into that release branch, instead of develop. Back-merging the bugfix into the release branch will eventually result in the bugfix being merged into develop too, when the release branch is finished. (If work in develop immediately requires this bugfix and cannot wait for the release branch to be finished, you may safely merge the bugfix into develop now already as well.)</p>
</blockquote>
<p>类型3：release branches，主要发行版，大部分人使用。<br>类型4：develop ，主要开发者版本，开发者使用通行版，最终要回归master。   </p>
<blockquote>
<p>作者原话摘抄：We consider origin&#x2F;develop to be the main branch where the source code of HEAD always reflects a state with the latest delivered development changes for the next release. Some would call this the “integration branch”. This is where any automatic nightly builds are built from.  </p>
</blockquote>
<p>类型5：feature branches，特性开发版本，这里可以允许开发者扩展多个分支，同时开发多种特性。    </p>
<blockquote>
<p>作者原话摘抄：Feature branches (or sometimes called topic branches) are used to develop new features for the upcoming or a distant future release. When starting development of a feature, the target release in which this feature will be incorporated may well be unknown at that point. The essence of a feature branch is that it exists as long as the feature is in development, but will eventually be merged back into develop (to definitely add the new feature to the upcoming release) or discarded (in case of a disappointing experiment).</p>
</blockquote>
<p>细节方面：<br>在某一个feature branch开发完成后，需要这样回归</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git chekout feature </span><br><span class="line">#Switched to branch &#x27;develop&#x27;</span><br><span class="line">git merge --no-ff myfeature </span><br><span class="line">#Updating ea1b82a..05e9557</span><br><span class="line">git branch -d myfeature </span><br><span class="line">#Deleted branch myfeature (was 05e9557).</span><br><span class="line">git push origin develop </span><br><span class="line">#从本地上传</span><br></pre></td></tr></table></figure>
<p>这里的合并使用了 git merge –no–ff myfeature，是为了避免fast-forward合并对合并的影响，是为了保留已经合并的myfeature记录。</p>
<h2 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h2><p>标签是为了更方便地参考提交而给它标上易懂的名称。<br>Git可以使用2种标签：轻标签和注解标签。打上的标签是固定的，不能像分支那样可以移动位置。</p>
<p>轻标签格式</p>
<ul>
<li>添加名称</li>
</ul>
<p>注解标签格式</p>
<ul>
<li>添加名称</li>
<li>添加注解</li>
<li>添加签名</li>
</ul>
<h2 id="改写提交"><a href="#改写提交" class="headerlink" title="改写提交"></a>改写提交</h2><p>改写提交是指对已经提交的提交记录进行修改或修正。在Git中，这通常用于更正提交信息、合并提交、重新排序提交或重新整理提交历史。</p>
<p>以下是一些常见的改写提交的操作：</p>
<ul>
<li>修改提交信息:你可以使用git commit –amend 命令来修改最新的提交信息。这会打开文本编辑器，允许你修改提交的注释。这在提交信息拼写错误或需要补充信息时很有用。</li>
<li>合并提交： 如果你发现你在之前的几次提交中有类似的修改，你可以使用交互式 rebase（git rebase -i）来合并这些提交，将它们合并成一个更大的提交。</li>
<li>重新排序提交： 使用交互式 rebase，你可以重新排序提交历史，改变提交的顺序。</li>
<li>删除提交： 使用交互式 rebase 或 git reset 命令，你可以删除不需要的提交。但要注意，删除已经被推送到远程仓库的提交可能会引起问题。</li>
<li>拆分提交： 通过交互式 rebase，你可以将一个大的提交拆分成多个较小的提交，从而更好地划分功能或修改。</li>
<li>修改文件内容： 如果你希望修改之前提交中的文件内容，你可以使用 git commit –amend 进行提交，并在其中修改文件内容。但要注意，修改已经被推送到远程仓库的提交可能会影响其他人。</li>
</ul>
<p>常见的改写命令：</p>
<ul>
<li>commit –amend  #修改最近一次的提交注释</li>
<li>revert  #用revert命令来取消提交</li>
<li>reset –hard HEAD~  #向后移动HEAD指针</li>
<li>cherry-pick +哈希值  #从分支当中根据哈希值来融进主支</li>
<li>用rebase -i 汇合提交  #合并两次提交，需要squash</li>
<li>用rebase -i 修改提交  #进行修改提交，需要edit</li>
<li>merge –squash  #把分支合并提交<br>其中reset当中的参数<br>模式名称	HEAD的位置	  索引	 工作树   主要使用场合<br>soft		修改		不修改	不修改   只取消提交<br>mixed		修改		修改	不修改   复原修改过的索引的状态<br>hard		修改		修改	修改     彻底取消最近的提交</li>
</ul>
]]></content>
      <categories>
        <category>编程学习笔记</category>
      </categories>
      <tags>
        <tag>完结</tag>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>聊聊自己对数据结构的感觉</title>
    <url>/2023/08/29/%E8%81%8A%E8%81%8A%E8%87%AA%E5%B7%B1%E5%AF%B9%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E6%84%9F%E8%A7%89/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>按照惯例，先写前言，这里只是谈一下数据结构的具体感觉，没有具体的实现过程，可能我后续会添加，看我水平，现在能力我自认确实拿不出手。</p>
<span id="more"></span>
<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>马上也要到毕业的时候了，现在对数据结构来建立一个总的认识，是再好不过的一次实践。<br>首先数据结构是发现的过程，而算法则是训练的过程<del>（不是自己原创，通过前辈分享的经验得到）</del>，它广泛存在于日常生活当中，我们人类的组织结构可以用Tree来打比方，人与人之间的交际网络可以用Graph来表示，丢垃圾倒垃圾可以用Stack来表示，排队买东西可以用Queue来表示，就连我们班级坐的位置都可以使用二维的Array来表示，数据结构和日常是贴近的，符合直觉和数学的。<br>是因为计算机越来越贴近生活，所需要的模型就会越贴近实际，这里有种形而上实现的感觉。<br>所以我们从底层认识数据结构，才符合常识，所有的程序都是有其硬件的支撑。<br>换成数据结构，就是数据结构是计算机中存储，组织数据的方式。<br>三个关键词，存储，组织<del>(就是CRUD)</del>，数据。<br>把有意义的数据组织起来合理的存储到系统当中去，那么系统当中是啥，是硬件的内存条，它的空间是有限的，是有RAM特性的随机存储的。在这里最基础的单位是位bit，8个bit合成一个byte，4个byte合成32bit，也就是int32，32位操作系统。64位操作系统就是8个byte，64bit。<br>不难看出空间的有限，所以会有一个标准来评判，提升空间的利用率。一个是空间复杂度，一个是时间复杂度。这里就不具体分析哪一个数据结构的复杂度了。一般很少使用空间复杂度，但是时间是和我们现实当中同步的，我们更看重时间复杂度，而且这确实更容易量化。<br>台子就这么搭建好了，一个有限的空间，32位或则64位的操作系统。<br>数据结构出场了，第一个上来的是静态数组static array，它在内存当中遵循back to back原则。也就是byte连续，是一个固定的顺序，因此有索引index，可以很方便的读取，但是空间有限，这个时候就引出了动态数组，动态数组采用了一个非常聪明的扩展静态数组的方法，成倍的扩展，成倍的索要空间，这里就如同这样的例子arr[3]&#x3D;{1,2,3}变为arr[6]&#x3D;{1,2,3,4,5,6}这里添加数据的时间复杂度从头到尾为:O(n),O(1),O(1),O(n),O(1),O(1)。如果进行衍生就会得到这样的公式(nO(1)+O(n))&#x2F;(n+1)&#x3D;O(1),好像有个专门的术语我忘了，这里就不细嗦说了。总而言之就是让动态数组的效率和静态数组别无二致。很吊。<br>第二个就是链表，链表就要提系统内存当中的地址了，起始数组也有地址，是首地址，所以很麻烦，数组如果把首元素删除，那么第二个元素就是第一个，第三个元素就是第二个，所以时间复杂度是O(n)，这是back to back的特性所致。<br>而链表就是捡一些废弃的小垃圾，一个指一个，也就是一个value，一个指针next，这是简单的Linked list。我需要指出一个非常好玩的就是Doubly linked list双向链表，前面是指针pre，中间是value，后面是指针next，这个有个非常直观的例子就是浏览器的前进和后退，音乐播放器的前进和后退。直观，符合数学，高效，简洁，很美。<br>之后再聊聊哈希Hash，哈希是一种加密解密的感觉，一种密码学的感觉，这种高级特工的神秘感，很重要，这种感觉体现在它的形式，key-value也就是键值对，加密在key-&gt;value，value-&gt;key中的-&gt;这个过程就是解密和加密的过程。这里时间复杂度非常高效，平均情况下CRUD全都是o(1),可以说是梦中数据结构，但是有一点就是会发生相同数据的情况，也就是可能会产生哈希碰撞。也就是密码学不再一一对应了，key-value失效了。这里介绍一个简单的处理方式，就是通过碰撞的两个的后面再添加一个链表就行了，前面是value值，后面是指向访问的人的key的指针，就行了。<br>这里举一个极端的案例，也就是我的哈希表全部指向同一个，然后密码学加密和没加密一样，那不就成为了一个单向链表Linked list么？是不是，所以说好玩。<br>接下来聊聊，Stack栈和Queue队列，模型很简单，可以说名字就表示了模型的由来，这里稍微想象一下就行了，毕竟我始终聊的是感觉，感觉不需要太理性。Stack先进后出，Queue先进先出。代码实现一般是Stack用array，Queue用Linked list。<br>就是下来就是聊树Tree和图Graph。<br>首先需要明确的是，树是一种特殊的图。用来表是现实当中的层级。而图则是表现现实当中的关系。树有根的的概念，这一点可以直接从开源系统Linux当中看的很清楚&#x2F;root，从根节点出发把所有的文件安排的都非常妥当，这里要提一个特殊的树，它在时间复杂度上有的O(logn)的好成绩，就是平衡二叉树AVL，可以说来自数学当中的二分查找，这里用到了编程。而图可以分为有向图，无向图，这里就不细嗦了。<br>以上可以算作全部内容了，感觉到此也就散了。</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>编程学习笔记</tag>
        <tag>完结</tag>
        <tag>碎碎念</tag>
      </tags>
  </entry>
  <entry>
    <title>学习git的叙述（搁置中）</title>
    <url>/2023/08/22/%E5%AD%A6%E4%B9%A0git%E7%9A%84%E5%8F%99%E8%BF%B0/</url>
    <content><![CDATA[<h1 id="前言说明"><a href="#前言说明" class="headerlink" title="前言说明"></a>前言说明</h1><p>根据以下资料自学，</p>
<ul>
<li><a href="https://backlog.com/git-tutorial/cn/">猴子都能懂的Git入门</a>（完成，已单发博文）</li>
<li><a href="https://learngitbranching.js.org/?locale=zh_CN">Learning Git Branching 在线游戏</a>(完成，已单发博文)</li>
<li><a href="https://docs.github.com/zh/get-started">GitHub 入门文档</a>（待学）</li>
<li><a href="https://github.phodal.com/#/">GitHub 漫游指南</a>（待学）</li>
<li><a href="https://oschina.gitee.io/opensource-guide/">开源指北</a>（待学）</li>
<li><a href="https://git-scm.com/book/zh/v2">Git官方文档</a>（待学）</li>
<li><a href="https://docs.github.com/zh">GitHub官方文档</a>（待学）</li>
</ul>
<h1 id="GitHub-入门文档的叙述"><a href="#GitHub-入门文档的叙述" class="headerlink" title="GitHub 入门文档的叙述"></a>GitHub 入门文档的叙述</h1><p>还未开始，在忙别的事情还。</p>
]]></content>
      <categories>
        <category>编程学习笔记</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>搁置</tag>
      </tags>
  </entry>
</search>
