<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>学习git的叙述（搁置中）</title>
    <url>/2023/08/22/%E5%AD%A6%E4%B9%A0git%E7%9A%84%E5%8F%99%E8%BF%B0/</url>
    <content><![CDATA[<h1 id="前言说明"><a href="#前言说明" class="headerlink" title="前言说明"></a>前言说明</h1><p>根据以下资料自学，</p>
<ul>
<li><a href="https://backlog.com/git-tutorial/cn/">猴子都能懂的Git入门</a>（完成，已单发博文）</li>
<li><a href="https://learngitbranching.js.org/?locale=zh_CN">Learning Git Branching 在线游戏</a>(完成，已单发博文)</li>
<li><a href="https://docs.github.com/zh/get-started">GitHub 入门文档</a>（待学）</li>
<li><a href="https://github.phodal.com/#/">GitHub 漫游指南</a>（待学）</li>
<li><a href="https://oschina.gitee.io/opensource-guide/">开源指北</a>（待学）</li>
<li><a href="https://git-scm.com/book/zh/v2">Git官方文档</a>（待学）</li>
<li><a href="https://docs.github.com/zh">GitHub官方文档</a>（待学）</li>
</ul>
<h1 id="GitHub-入门文档的叙述"><a href="#GitHub-入门文档的叙述" class="headerlink" title="GitHub 入门文档的叙述"></a>GitHub 入门文档的叙述</h1><p>还未开始，在忙别的事情还。</p>
]]></content>
      <categories>
        <category>编程学习笔记</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>搁置</tag>
      </tags>
  </entry>
  <entry>
    <title>算法导论阅读笔记（搁置中）</title>
    <url>/2023/08/27/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>大一的时候买的书，一直说以后看，以后看，这一推就到了现在，不能再推下去了。<br>现在开始啃这本书，可以说我是抱着巨大的勇气进行的，特别决定了还要发到博客当中去监督自己的这一决心。<br>所以这个系列在表述的过程当中可能会有误，希望有大佬看到错误的地方可以私发我邮件，或则评论区指出，无论有多尖锐都请您随意发出，不用客气的批评我，这里再次表达感激之情。<br>现在让我开始啃这个巨著吧，争取做到日更。</p>
<h1 id="第一部分-基础知识"><a href="#第一部分-基础知识" class="headerlink" title="第一部分 基础知识"></a>第一部分 基础知识</h1><h2 id="第1章-算法在计算中的作用"><a href="#第1章-算法在计算中的作用" class="headerlink" title="第1章 算法在计算中的作用"></a>第1章 算法在计算中的作用</h2><h3 id="1-1-算法"><a href="#1-1-算法" class="headerlink" title="1.1 算法"></a>1.1 算法</h3><p>算法就是任何良定义的计算过程，也可以看作是用于求解良说明的计算问题的工具。<br>良定义包含四个方面：明确性，有限性，输入和输出，可行性。<br>良说明包含五个方面：输入， 输出，约束条件，问题的性质，示例。</p>
<p>许多有趣算法问题所共有的两个特征：<br>1.存在许多候选解<br>2.存在实际应用<br>候选解指的是：候选解是指在解决问题或完成任务时，被认为可能是正确或有效解决方案的一个潜在选择。</p>
<p>NP完全的问题需要满足两个条件：<br>1.可证明性<br>2.NP难度</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">举例子：想象你在玩一个拼图游戏，你得到了一些拼图块，而且你需要将它们组合成一个完整的拼图。如果你把所有的拼图块正确地组合在一起，你可以很容易地看到结果是正确的。这就是“可证明性”，因为你可以验证最终拼图是否正确。    </span><br><span class="line">现在，假设你没有完整的拼图图像，而是零散地得到一块块拼图，然后需要找到一个方法将它们组合起来。NP-完全问题就类似于这种情况。它们要求你找到一个解，就像是将零散的拼图块组合在一起，以满足某些条件。这些问题很难，因为找到这种解看起来并不容易。   </span><br><span class="line">但是，如果你告诉别人你已经找到了一个可能的拼图组合方式，别人可以很快地验证它是否正确。这就是问题的“可证明性”。NP-完全问题的关键在于，如果你能够在快速的时间内验证一个可能的解，那么理论上你也可以在快速的时间内找到一个解。这就是为什么这些问题被认为是非常困难的，因为目前我们没有找到一种快速的方法来解决它们，但如果我们找到了一个解，我们可以快速地验证它是否正确。</span><br></pre></td></tr></table></figure>

<p>练习:<br>1.1-1     </p>
<h3 id="1-2-作为一种技术的算法"><a href="#1-2-作为一种技术的算法" class="headerlink" title="1.2 作为一种技术的算法"></a>1.2 作为一种技术的算法</h3>]]></content>
      <categories>
        <category>编程学习笔记</category>
      </categories>
      <tags>
        <tag>算法导论</tag>
        <tag>阅读笔记</tag>
        <tag>搁置</tag>
      </tags>
  </entry>
  <entry>
    <title>《猴子都能懂的Git入门》学习笔记（已完结）</title>
    <url>/2023/08/28/%E3%80%8A%E7%8C%B4%E5%AD%90%E9%83%BD%E8%83%BD%E6%87%82%E7%9A%84Git%E5%85%A5%E9%97%A8%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="内容叙述–猴子都能懂的Git入门（已完结）"><a href="#内容叙述–猴子都能懂的Git入门（已完结）" class="headerlink" title="内容叙述–猴子都能懂的Git入门（已完结）"></a>内容叙述–猴子都能懂的Git入门（已完结）</h1><h2 id="首先"><a href="#首先" class="headerlink" title="首先"></a>首先</h2><p>Git是一个分布式版本管理系统，是为了更好地管理Linux内核开发而创立的。<br>用Git管理文件，更新的历史会保存在Git。<br>如果和别人共享文件修改时有冲突，会发出报错警告。  </p>
<span id="more"></span>
<h2 id="Git的数据库"><a href="#Git的数据库" class="headerlink" title="Git的数据库"></a>Git的数据库</h2><p>数据库 (Repository) 是记录文件或目录状态的地方，存储着内容修改的历史记录。<br>Git的数据库分为远程数据库和本地数据库的两种。<br>远程数据库和本地数据库的交流为pull和push。<br>其中：创建本地数据库的方法有两种：一种是创建全新的数据库，另一种是复制远程数据库。<br>提交到远程数据库为了方便协同合作，务必输入准确简洁的提交信息，遵循下列Git的标准注解原则：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">第1行：提交修改内容的摘要</span><br><span class="line">第2行：空行</span><br><span class="line">第3行以后：修改的理由</span><br></pre></td></tr></table></figure>

<h2 id="工作树和索引"><a href="#工作树和索引" class="headerlink" title="工作树和索引"></a>工作树和索引</h2><p>在Git管理下，大家实际操作的目录被称为工作树。<br>在数据库和工作树之间有索引，索引是为了向数据库提交作准备的区域。<br>凭借中间的索引，可以避免工作树中不必要的文件提交，还可以将文件修改内容的一部分加入索引区域并提交。</p>
<h2 id="实操的提前准备"><a href="#实操的提前准备" class="headerlink" title="实操的提前准备"></a>实操的提前准备</h2><p>首先安装<a href="http://msysgit.github.io/">git</a>，再安装开放源代码的Git客户端<a href="http://code.google.com/p/tortoisegit/">TortoiseGit</a>（有官方汉化语言包）。</p>
<h2 id="版本库，工作树，暂存区"><a href="#版本库，工作树，暂存区" class="headerlink" title="版本库，工作树，暂存区"></a>版本库，工作树，暂存区</h2><p>版本库（Repository）： 在Git中，版本库是存储代码历史记录的地方。它包括了整个项目的历史状态、分支、标签等信息。当你执行git init命令创建一个新的版本库时，Git会在你的项目文件夹中生成一个名为.git的隐藏文件夹，这个文件夹就是版本库。</p>
<p>工作树（Working Tree）： 工作树是你项目文件夹中的实际文件和文件夹，它反映了你当前的工作状态。在工作树中进行的文件修改、添加、删除等操作都会被记录下来，然后可以通过提交到版本库来保留这些修改。</p>
<p>暂存区（Staging Area）： 暂存区是位于版本库和工作树之间的一个缓冲区域。当你使用git add命令将文件添加到暂存区时，你正在告诉Git这些文件将会被包含在下一次的提交中。</p>
<p>在操作过程中，文件会从工作树添加到暂存区，然后再从暂存区提交到版本库中。这种分层结构使得Git能够记录代码的变更历史并支持版本控制。</p>
<h2 id="解决冲突"><a href="#解决冲突" class="headerlink" title="解决冲突"></a>解决冲突</h2><p>当前一个数据和后一个数据冲突，需要对手动来解决冲突，我们首先需要pull，得到远程别人最新的修改版本，到本地来对照自己的版本，解决冲突之后再上传push。</p>
<h2 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h2><p>分支是为了将修改记录的整体流程分叉保存。分叉后的分支不受其他分支的影响，所以在同一个数据库里可以同时进行多个修改。<br>为了不受其他开发人员的影响，您可以在主分支上建立自己专用的分支。完成工作后，将自己分支上的修改合并到主分支。因为每一次提交的历史记录都会被保存，所以当发生问题时，定位和修改造成问题的提交就容易多了。</p>
<h3 id="常见的两种分支形式"><a href="#常见的两种分支形式" class="headerlink" title="常见的两种分支形式"></a>常见的两种分支形式</h3><p>Merge分支是为了可以随时发布release而创建的分支，它还能作为Topic分支的源分支使用。保持分支稳定的状态是很重要的。通常，大家会将master分支当作Merge分支使用。</p>
<p>Topic分支是为了开发新功能或修复Bug等任务而建立的分支。若要同时进行多个的任务，请创建多个的Topic分支。Topic分支是从稳定的Merge分支创建的。完成作业后，要把Topic分支合并回Merge分支。</p>
<h3 id="分支的切换"><a href="#分支的切换" class="headerlink" title="分支的切换"></a>分支的切换</h3><p>若要切换作业的分支，就要进行checkout操作。进行checkout时，git会从工作树还原向目标分支提交的修改内容。checkout之后的提交记录将被追加到目标分支。<br>这里需要注意的是，还原的是git本地的，工作区和暂存区，还原之后，就会把版本库和工作树切换到全新的分支。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git checkout -b branchB #-b的参数是branch的意思</span><br><span class="line">git checkout branchB #这里是切换到branchB，如果没有需要加-b参数，切换并创建</span><br></pre></td></tr></table></figure>

<h3 id="head指针"><a href="#head指针" class="headerlink" title="head指针"></a>head指针</h3><p>涉及到分支的切换，就需要了解head的指针，HEAD指向的是现在使用中的分支的最后一次更新。通常默认指向master分支的最后一次更新。通过移动HEAD，就可以变更使用的分支。</p>
<blockquote>
<p>举一个例子：<br>假设你有一个提交历史记录 A -&gt; B -&gt; C -&gt; D -&gt; E，并且”HEAD” 当前指向 E。</p>
</blockquote>
<blockquote>
<p>如果你想要创建一个新的分支 B2，可以使用 git checkout -b B2 命令。这会在 E 的位置创建一个新分支 B2，然后将”HEAD” 移动到 B2，意味着你在 B2 分支上开始了新的工作。</p>
</blockquote>
<blockquote>
<p>如果你想要将版本回退到 C，你可以使用 git reset –hard C 命令。这将会让”HEAD” 和当前分支都指向 C，你的工作树和暂存区也会被还原为 C 的状态。</p>
</blockquote>
<blockquote>
<p>通过切换分支或回退版本，”HEAD” 会移动到不同的提交位置，指向不同的分支或提交。</p>
</blockquote>
<h3 id="stash操作"><a href="#stash操作" class="headerlink" title="stash操作"></a>stash操作</h3><p>还未提交的修改内容以及新添加的文件，留在索引区域或工作树的情况下切换到其他的分支时，修改内容会从原来的分支移动到目标分支。<br>但是如果在checkout的目标分支中相同的文件也有修改，checkout会失败的。这时要么先提交修改内容，要么用stash暂时保存修改内容后再checkout。<br>stash是临时保存文件修改内容的区域。stash可以暂时保存工作树和索引里还没提交的修改内容，您可以事后再取出暂存的修改，应用到原先的分支或其他的分支上。<br>总结：”stash” 在Git中指的是暂时隐藏未提交修改的操作，使你可以在不提交修改的情况下进行其他操作。</p>
<h2 id="分支的合并"><a href="#分支的合并" class="headerlink" title="分支的合并"></a>分支的合并</h2><p>合并分支有2种方法：使用merge或rebase</p>
<h3 id="merge"><a href="#merge" class="headerlink" title="merge"></a>merge</h3><p>merge合并是将一个分支的更改合并到另一个分支的常见方法。合并创建一个新的提交，将两个分支的更改整合到一起。合并提交将会有多个父提交，分别来自于要合并的两个分支。这种方法适用于保留分支历史，使每个分支的更改都能够清楚地追踪。</p>
<h3 id="rebase"><a href="#rebase" class="headerlink" title="rebase"></a>rebase</h3><p>Rebase变基是另一种将分支更改整合的方法，它的目标是创建一个线性的提交历史，使分支看起来像是连续的。在变基过程中，你从一个分支 “复制” 更改，然后将它们 “粘贴” 到另一个分支的末尾。这使得提交历史看起来更干净，但也可能会改变提交的顺序和提交的 SHA 标识。</p>
<p>总结区别：<br>Merge 会创建一个合并提交，它反映了分支间的合并。<br>Rebase 会将源分支的更改逐个应用到目标分支的末尾，形成一个线性的提交历史。</p>
<h3 id="git分支的应用"><a href="#git分支的应用" class="headerlink" title="git分支的应用"></a>git分支的应用</h3><p>点击查看Vincent Driessen大佬的博文<a href="http://nvie.com/posts/a-successful-git-branching-model/">A successful Git branching model</a><br>阅读原文推荐浏览器插件沙拉查词，或则使用欧路词典eudic。<br>作者在时间的推移当中，划分了五个不同类型的branch。<br>类型1：master，主类型，起label的作用，确定档号，最稳定版。    </p>
<blockquote>
<p>作者原话摘抄：We consider origin&#x2F;master to be the main branch where the source code of HEAD always reflects a production-ready state.  </p>
</blockquote>
<p>类型2：hotfixes，紧急类型，起熬夜加班修bug类型,修完之后需要立刻更新到其他develop和master分支上。   </p>
<blockquote>
<p>Hotfix branches are very much like release branches in that they are also meant to prepare for a new production release, albeit unplanned. They arise from the necessity to act immediately upon an undesired state of a live production version. When a critical bug in a production version must be resolved immediately, a hotfix branch may be branched off from the corresponding tag on the master branch that marks the production version.</p>
</blockquote>
<blockquote>
<p>The one exception to the rule here is that, when a release branch currently exists, the hotfix changes need to be merged into that release branch, instead of develop. Back-merging the bugfix into the release branch will eventually result in the bugfix being merged into develop too, when the release branch is finished. (If work in develop immediately requires this bugfix and cannot wait for the release branch to be finished, you may safely merge the bugfix into develop now already as well.)</p>
</blockquote>
<p>类型3：release branches，主要发行版，大部分人使用。<br>类型4：develop ，主要开发者版本，开发者使用通行版，最终要回归master。   </p>
<blockquote>
<p>作者原话摘抄：We consider origin&#x2F;develop to be the main branch where the source code of HEAD always reflects a state with the latest delivered development changes for the next release. Some would call this the “integration branch”. This is where any automatic nightly builds are built from.  </p>
</blockquote>
<p>类型5：feature branches，特性开发版本，这里可以允许开发者扩展多个分支，同时开发多种特性。    </p>
<blockquote>
<p>作者原话摘抄：Feature branches (or sometimes called topic branches) are used to develop new features for the upcoming or a distant future release. When starting development of a feature, the target release in which this feature will be incorporated may well be unknown at that point. The essence of a feature branch is that it exists as long as the feature is in development, but will eventually be merged back into develop (to definitely add the new feature to the upcoming release) or discarded (in case of a disappointing experiment).</p>
</blockquote>
<p>细节方面：<br>在某一个feature branch开发完成后，需要这样回归</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git chekout feature </span><br><span class="line">#Switched to branch &#x27;develop&#x27;</span><br><span class="line">git merge --no-ff myfeature </span><br><span class="line">#Updating ea1b82a..05e9557</span><br><span class="line">git branch -d myfeature </span><br><span class="line">#Deleted branch myfeature (was 05e9557).</span><br><span class="line">git push origin develop </span><br><span class="line">#从本地上传</span><br></pre></td></tr></table></figure>
<p>这里的合并使用了 git merge –no–ff myfeature，是为了避免fast-forward合并对合并的影响，是为了保留已经合并的myfeature记录。</p>
<h2 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h2><p>标签是为了更方便地参考提交而给它标上易懂的名称。<br>Git可以使用2种标签：轻标签和注解标签。打上的标签是固定的，不能像分支那样可以移动位置。</p>
<p>轻标签格式</p>
<ul>
<li>添加名称</li>
</ul>
<p>注解标签格式</p>
<ul>
<li>添加名称</li>
<li>添加注解</li>
<li>添加签名</li>
</ul>
<h2 id="改写提交"><a href="#改写提交" class="headerlink" title="改写提交"></a>改写提交</h2><p>改写提交是指对已经提交的提交记录进行修改或修正。在Git中，这通常用于更正提交信息、合并提交、重新排序提交或重新整理提交历史。</p>
<p>以下是一些常见的改写提交的操作：</p>
<ul>
<li>修改提交信息:你可以使用git commit –amend 命令来修改最新的提交信息。这会打开文本编辑器，允许你修改提交的注释。这在提交信息拼写错误或需要补充信息时很有用。</li>
<li>合并提交： 如果你发现你在之前的几次提交中有类似的修改，你可以使用交互式 rebase（git rebase -i）来合并这些提交，将它们合并成一个更大的提交。</li>
<li>重新排序提交： 使用交互式 rebase，你可以重新排序提交历史，改变提交的顺序。</li>
<li>删除提交： 使用交互式 rebase 或 git reset 命令，你可以删除不需要的提交。但要注意，删除已经被推送到远程仓库的提交可能会引起问题。</li>
<li>拆分提交： 通过交互式 rebase，你可以将一个大的提交拆分成多个较小的提交，从而更好地划分功能或修改。</li>
<li>修改文件内容： 如果你希望修改之前提交中的文件内容，你可以使用 git commit –amend 进行提交，并在其中修改文件内容。但要注意，修改已经被推送到远程仓库的提交可能会影响其他人。</li>
</ul>
<p>常见的改写命令：</p>
<ul>
<li>commit –amend  #修改最近一次的提交注释</li>
<li>revert  #用revert命令来取消提交</li>
<li>reset –hard HEAD~  #向后移动HEAD指针</li>
<li>cherry-pick +哈希值  #从分支当中根据哈希值来融进主支</li>
<li>用rebase -i 汇合提交  #合并两次提交，需要squash</li>
<li>用rebase -i 修改提交  #进行修改提交，需要edit</li>
<li>merge –squash  #把分支合并提交<br>其中reset当中的参数<br>模式名称	HEAD的位置	  索引	 工作树   主要使用场合<br>soft		修改		不修改	不修改   只取消提交<br>mixed		修改		修改	不修改   复原修改过的索引的状态<br>hard		修改		修改	修改     彻底取消最近的提交</li>
</ul>
]]></content>
      <categories>
        <category>编程学习笔记</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>完结</tag>
      </tags>
  </entry>
  <entry>
    <title>Learning Git Branching 在线游戏 学习记录（已完结）</title>
    <url>/2023/08/28/Learning-Git-Branching-%E5%9C%A8%E7%BA%BF%E6%B8%B8%E6%88%8F-%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h1 id="内容叙述–Learning-Git-Branching-在线游戏（在玩）"><a href="#内容叙述–Learning-Git-Branching-在线游戏（在玩）" class="headerlink" title="内容叙述–Learning Git Branching 在线游戏（在玩）"></a>内容叙述–Learning Git Branching 在线游戏（在玩）</h1><p>游戏有如下的关卡：</p>
<ul>
<li>基础篇3关，</li>
<li>高级篇3关，</li>
<li>移动提交记录2个，</li>
<li>杂项5个，</li>
<li>高级话题3个，</li>
<li>git远程仓库8个</li>
<li>git远程仓库高级操作8个<span id="more"></span></li>
</ul>
<h2 id="基础篇"><a href="#基础篇" class="headerlink" title="基础篇"></a>基础篇</h2><h3 id="Git-Commit"><a href="#Git-Commit" class="headerlink" title="Git Commit"></a>Git Commit</h3><p>Git 仓库中的提交记录保存的是你的目录下所有文件的快照，就像是把整个目录复制，然后再粘贴一样，但比复制粘贴优雅许多！   </p>
<p>Git 希望提交记录尽可能地轻量，因此在你每次进行提交时，它并不会盲目地复制整个目录。条件允许的情况下，它会将当前版本与仓库中的上一个版本进行对比，并把所有的差异打包到一起作为一个提交记录。    </p>
<h3 id="Git-Branch"><a href="#Git-Branch" class="headerlink" title="Git Branch"></a>Git Branch</h3><p>Git 的分支也非常轻量。它们只是简单地<strong>指向</strong>某个提交纪录 —— 仅此而已。所以许多 Git 爱好者传颂：<br><strong>早建分支！多用分支！</strong><br>这是因为即使创建再多的分支也不会造成储存或内存上的开销，并且按逻辑分解工作到不同的分支要比维护那些特别臃肿的分支简单多了。</p>
<p>注意：在 Git 2.23 版本中，引入了一个名为 git switch 的新命令，最终会取代 git checkout，因为 checkout 作为单个命令有点超载（它承载了很多独立的功能）。 由于现在很多人还无法使用 switch，本次课程仍然使用 checkout 而不是 switch， 但是如果你想尝试一下新命令，我们的应用也是支持的！并且你可以从<a href="https://git-scm.com/docs/git-switch">这里</a>学到更多关于新命令的内容。</p>
<h3 id="Git-Merge"><a href="#Git-Merge" class="headerlink" title="Git Merge"></a>Git Merge</h3><p>太好了! 我们已经知道如何提交以及如何使用分支了。接下来咱们看看如何将两个分支合并到一起。就是说我们新建一个分支，在其上开发某个新功能，开发完成后再合并回主线。</p>
<p>咱们先来看一下第一种方法 —— git merge。在 Git 中合并两个分支时会产生一个特殊的提交记录，它有两个 parent 节点。翻译成自然语言相当于：“我要把这两个 parent 节点本身及它们所有的祖先都包含进来。”</p>
<h3 id="Git-Rebase"><a href="#Git-Rebase" class="headerlink" title="Git Rebase"></a>Git Rebase</h3><p>第二种合并分支的方法是 git rebase。Rebase 实际上就是取出一系列的提交记录，“复制”它们，然后在另外一个地方逐个的放下去。</p>
<p>Rebase 的优势就是可以创造更线性的提交历史，这听上去有些难以理解。如果只允许使用 Rebase 的话，代码库的提交历史将会变得异常清晰。</p>
<h2 id="高级篇"><a href="#高级篇" class="headerlink" title="高级篇"></a>高级篇</h2><h3 id="HEAD"><a href="#HEAD" class="headerlink" title="HEAD"></a>HEAD</h3><p>HEAD 是一个对当前所在分支的符号引用 —— 也就是指向你正在其基础上进行工作的提交记录。</p>
<p>HEAD 总是指向当前分支上最近一次提交记录。大多数修改提交树的 Git 命令都是从改变 HEAD 的指向开始的。</p>
<p>HEAD 通常情况下是指向分支名的（如 bugFix）。在你提交时，改变了 bugFix 的状态，这一变化通过 HEAD 变得可见。</p>
<h3 id="相对引用"><a href="#相对引用" class="headerlink" title="相对引用"></a>相对引用</h3><p>通过指定提交记录哈希值的方式在 Git 中移动不太方便。在实际应用时，并没有像本程序中这么漂亮的可视化提交树供你参考，所以你就不得不用 git log 来查查看提交记录的哈希值。</p>
<p>并且哈希值在真实的 Git 世界中也会更长（译者注：基于 SHA-1，共 40 位）。例如前一关的介绍中的提交记录的哈希值可能是 fed2da64c0efc5293610bdd892f82a58e8cbc5d8。舌头都快打结了吧…</p>
<p>比较令人欣慰的是，Git 对哈希的处理很智能。你只需要提供能够唯一标识提交记录的前几个字符即可。因此我可以仅输入fed2 而不是上面的一长串字符。<br>正如我前面所说，通过哈希值指定提交记录很不方便，所以 Git 引入了相对引用。这个就很厉害了!</p>
<p>使用相对引用的话，你就可以从一个易于记忆的地方（比如 bugFix 分支或 HEAD）开始计算。</p>
<p>相对引用非常给力，这里我介绍两个简单的用法：</p>
<p>使用 ^ 向上移动 1 个提交记录<br>使用 ~&lt; num &gt; 向上移动多个提交记录，如 ~3</p>
<p>“~”操作符<br>如果你想在提交树中向上移动很多步的话，敲那么多 ^ 貌似也挺烦人的，Git 当然也考虑到了这一点，于是又引入了操作符 ~。</p>
<p>该操作符后面可以跟一个数字（可选，不跟数字时与 ^ 相同，向上移动一次），指定向上移动多少次。咱们还是通过实际操作看一下吧</p>
<h3 id="撤销变更"><a href="#撤销变更" class="headerlink" title="撤销变更"></a>撤销变更</h3><p>在 Git 里撤销变更的方法很多。和提交一样，撤销变更由底层部分（暂存区的独立文件或者片段）和上层部分（变更到底是通过哪种方式被撤销的）组成。我们这个应用主要关注的是后者。</p>
<p>主要有两种方法用来撤销变更 —— 一是 git reset，还有就是 git revert。接下来咱们逐个进行讲解。</p>
<p>git reset 通过把分支记录回退几个提交记录来实现撤销改动。你可以将这想象成“改写历史”。git reset 向上移动分支，原来指向的提交记录就跟从来没有提交过一样。</p>
<p>虽然在你的本地分支中使用 git reset 很方便，但是这种“改写历史”的方法对大家一起使用的远程分支是无效的哦！</p>
<p>为了撤销更改并分享给别人，我们需要使用 git revert。</p>
<h2 id="移动提交记录"><a href="#移动提交记录" class="headerlink" title="移动提交记录"></a>移动提交记录</h2><h3 id="Git-Cherry-pick"><a href="#Git-Cherry-pick" class="headerlink" title="Git Cherry-pick"></a>Git Cherry-pick</h3><p>本系列的第一个命令是 git cherry-pick, 命令形式为:</p>
<p>git cherry-pick &lt;提交号&gt;…<br>如果你想将一些提交复制到当前所在的位置（HEAD）下面的话， Cherry-pick 是最直接的方式了。我个人非常喜欢 cherry-pick，因为它特别简单。</p>
<h3 id="交互式的-rebase"><a href="#交互式的-rebase" class="headerlink" title="交互式的 rebase"></a>交互式的 rebase</h3><p>当你知道你所需要的提交记录（并且还知道这些提交记录的哈希值）时, 用 cherry-pick 再好不过了 —— 没有比这更简单的方式了。</p>
<p>但是如果你不清楚你想要的提交记录的哈希值呢? 幸好 Git 帮你想到了这一点, 我们可以利用交互式的 rebase —— 如果你想从一系列的提交记录中找到想要的记录, 这就是最好的方法了</p>
<p>交互式 rebase 指的是使用带参数 –interactive 的 rebase 命令, 简写为 -i</p>
<p>如果你在命令后增加了这个选项, Git 会打开一个 UI 界面并列出将要被复制到目标分支的备选提交记录，它还会显示每个提交记录的哈希值和提交说明，提交说明有助于你理解这个提交进行了哪些更改。</p>
<h2 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h2><h3 id="本地栈式提交"><a href="#本地栈式提交" class="headerlink" title="本地栈式提交"></a>本地栈式提交</h3><p>来看一个在开发中经常会遇到的情况：我正在解决某个特别棘手的 Bug，为了便于调试而在代码中添加了一些调试命令并向控制台打印了一些信息。</p>
<p>这些调试和打印语句都在它们各自的提交记录里。最后我终于找到了造成这个 Bug 的根本原因，解决掉以后觉得沾沾自喜！</p>
<p>最后就差把 bugFix 分支里的工作合并回 main 分支了。你可以选择通过 fast-forward 快速合并到 main 分支上，但这样的话 main 分支就会包含我这些调试语句了。你肯定不想这样，应该还有更好的方式……</p>
<p>实际我们只要让 Git 复制解决问题的那一个提交记录就可以了。跟之前我们在“整理提交记录”中学到的一样，我们可以使用</p>
<p>git rebase -i<br>git cherry-pick<br>来达到目的。</p>
<h3 id="提交的技巧-1"><a href="#提交的技巧-1" class="headerlink" title="提交的技巧 #1"></a>提交的技巧 #1</h3><p>接下来这种情况也是很常见的：你之前在 newImage 分支上进行了一次提交，然后又基于它创建了 caption 分支，然后又提交了一次。</p>
<p>此时你想对某个以前的提交记录进行一些小小的调整。比如设计师想修改一下 newImage 中图片的分辨率，尽管那个提交记录并不是最新的了。</p>
<p>我们可以通过下面的方法来克服困难：</p>
<p>先用 git rebase -i 将提交重新排序，然后把我们想要修改的提交记录挪到最前<br>然后用 git commit –amend 来进行一些小修改<br>接着再用 git rebase -i 来将他们调回原来的顺序<br>最后我们把 main 移到修改的最前端（用你自己喜欢的方法），就大功告成啦！<br>当然完成这个任务的方法不止上面提到的一种（我知道你在看 cherry-pick 啦），之后我们会多点关注这些技巧啦，但现在暂时只专注上面这种方法。</p>
<h3 id="提交的技巧-2"><a href="#提交的技巧-2" class="headerlink" title="提交的技巧 #2"></a>提交的技巧 #2</h3><p>正如你在上一关所见到的，我们可以使用 rebase -i 对提交记录进行重新排序。只要把我们想要的提交记录挪到最前端，我们就可以很轻松的用 –amend 修改它，然后把它们重新排成我们想要的顺序。</p>
<p>但这样做就唯一的问题就是要进行两次排序，而这有可能造成由 rebase 而导致的冲突。下面还是看看 git cherry-pick 是怎么做的吧。</p>
<h3 id="Git-Tags"><a href="#Git-Tags" class="headerlink" title="Git Tags"></a>Git Tags</h3><p>相信通过前面课程的学习你已经发现了：分支很容易被人为移动，并且当有新的提交时，它也会移动。分支很容易被改变，大部分分支还只是临时的，并且还一直在变。</p>
<p>你可能会问了：有没有什么可以永远指向某个提交记录的标识呢，比如软件发布新的大版本，或者是修正一些重要的 Bug 或是增加了某些新特性，有没有比分支更好的可以永远指向这些提交的方法呢？</p>
<p>当然有了！Git 的 tag 就是干这个用的啊，它们可以（在某种程度上 —— 因为标签可以被删除后重新在另外一个位置创建同名的标签）永久地将某个特定的提交命名为里程碑，然后就可以像分支一样引用了。</p>
<p>更难得的是，它们并不会随着新的提交而移动。你也不能切换到某个标签上面进行修改提交，它就像是提交树上的一个锚点，标识了某个特定的位置。</p>
<h3 id="Git-Describe"><a href="#Git-Describe" class="headerlink" title="Git Describe"></a>Git Describe</h3><p>由于标签在代码库中起着“锚点”的作用，Git 还为此专门设计了一个命令用来描述离你最近的锚点（也就是标签），它就是 git describe！</p>
<p>Git Describe 能帮你在提交历史中移动了多次以后找到方向；当你用 git bisect（一个查找产生 Bug 的提交记录的指令）找到某个提交记录时，或者是当你坐在你那刚刚度假回来的同事的电脑前时， 可能会用到这个命令。</p>
<p>git describe 的​​语法是：</p>
<p>git describe &lt; ref &gt;</p>
<p>&lt; ref &gt; 可以是任何能被 Git 识别成提交记录的引用，如果你没有指定的话，Git 会使用你目前所在的位置（HEAD）。</p>
<p>它输出的结果是这样的：</p>
<p>&lt; tag &gt;_&lt; numCommits &gt;_g&lt; hash &gt;</p>
<p>tag 表示的是离 ref 最近的标签， numCommits 是表示这个 ref 与 tag 相差有多少个提交记录， hash 表示的是你所给定的 ref 所表示的提交记录哈希值的前几位。</p>
<p>当 ref 提交记录上有某个标签时，则只输出标签名称</p>
<h2 id="高级话题"><a href="#高级话题" class="headerlink" title="高级话题"></a>高级话题</h2><h3 id="多分支-rebase"><a href="#多分支-rebase" class="headerlink" title="多分支 rebase"></a>多分支 rebase</h3><p>哇，现在我们这里出现了很多分支呢！让我们把所有这些分支上所做的工作都通过 rebase 合并到 main 分支上吧。</p>
<p>但是你的领导给你提了点要求 —— 他们希望得到有序的提交历史，也就是我们最终的结果应该是 C6’ 在 C7’ 上面， C5’ 在 C6’ 上面，依此类推。</p>
<h3 id="选择-parent-提交记录"><a href="#选择-parent-提交记录" class="headerlink" title="选择 parent 提交记录"></a>选择 parent 提交记录</h3><p>操作符 ^ 与 ~ 符一样，后面也可以跟一个数字。</p>
<p>但是该操作符后面的数字与 ~ 后面的不同，并不是用来指定向上返回几代，而是指定合并提交记录的某个 parent 提交。还记得前面提到过的一个合并提交有两个 parent 提交吧，所以遇到这样的节点时该选择哪条路径就不是很清晰了。</p>
<p>Git 默认选择合并提交的“第一个” parent 提交，在操作符 ^ 后跟一个数字可以改变这一默认行为。例如HEAD^2</p>
<h3 id="纠缠不清的分支"><a href="#纠缠不清的分支" class="headerlink" title="纠缠不清的分支"></a>纠缠不清的分支</h3><p>多次使用git rebase相关即可通关。</p>
<h2 id="git远程仓库"><a href="#git远程仓库" class="headerlink" title="git远程仓库"></a>git远程仓库</h2><h3 id="git-clone"><a href="#git-clone" class="headerlink" title="git clone"></a>git clone</h3><p>远程仓库并不复杂, 在如今的云计算盛行的世界很容易把远程仓库想象成一个富有魔力的东西, 但实际上它们只是你的仓库在另个一台计算机上的拷贝。你可以通过因特网与这台计算机通信 —— 也就是增加或是获取提交记录</p>
<p>话虽如此, 远程仓库却有一系列强大的特性</p>
<p>首先也是最重要的的点, 远程仓库是一个强大的备份。本地仓库也有恢复文件到指定版本的能力, 但所有的信息都是保存在本地的。有了远程仓库以后，即使丢失了本地所有数据, 你仍可以通过远程仓库拿回你丢失的数据。</p>
<p>还有就是, 远程让代码社交化了! 既然你的项目被托管到别的地方了, 你的朋友可以更容易地为你的项目做贡献(或者拉取最新的变更)</p>
<p>现在用网站来对远程仓库进行可视化操作变得越发流行了(像 GitHub), 但远程仓库永远是这些工具的顶梁柱, 因此理解其概念非常的重要!</p>
<p>直到现在, 教程都聚焦于本地仓库的操作（branch、merge、rebase 等等）。但我们现在需要学习远程仓库的操作 —— 我们需要一个配置这种环境的命令, 它就是 git clone。 从技术上来讲，git clone 命令在真实的环境下的作用是在本地创建一个远程仓库的拷贝（比如从 github.com）。</p>
<h3 id="远程分支"><a href="#远程分支" class="headerlink" title="远程分支"></a>远程分支</h3><p>远程分支反映了远程仓库(在你上次和它通信时)的状态。这会有助于你理解本地的工作与公共工作的差别 —— 这是你与别人分享工作成果前至关重要的一步.</p>
<p>远程分支有一个特别的属性，在你切换到远程分支时，自动进入分离 HEAD 状态。Git 这么做是出于不能直接在这些分支上进行操作的原因, 你必须在别的地方完成你的工作, （更新了远程分支之后）再用远程分享你的工作成果。</p>
<p>你可能想问这些远程分支的前面的 o&#x2F; 是什么意思呢？好吧, 远程分支有一个命名规范 —— 它们的格式是:</p>
<p>&lt; remote name &gt;&#x2F;&lt; branch name &gt;<br>因此，如果你看到一个名为 o&#x2F;main 的分支，那么这个分支就叫 main，远程仓库的名称就是 o。</p>
<p>大多数的开发人员会将它们主要的远程仓库命名为 origin，并不是 o。这是因为当你用 git clone 某个仓库时，Git 已经帮你把远程仓库的名称设置为 origin 了</p>
<p>不过 origin 对于我们的 UI 来说太长了，因此不得不使用简写 o :) 但是要记住, 当你使用真正的 Git 时, 你的远程仓库默认为 origin!</p>
<h3 id="Git-Fetch"><a href="#Git-Fetch" class="headerlink" title="Git Fetch"></a>Git Fetch</h3><p>Git 远程仓库相当的操作实际可以归纳为两点：向远程仓库传输数据以及从远程仓库获取数据。既然我们能与远程仓库同步，那么就可以分享任何能被 Git 管理的更新（因此可以分享代码、文件、想法、情书等等）。</p>
<p>本节课我们将学习如何从远程仓库获取数据 —— 命令如其名，它就是 git fetch。</p>
<p>你会看到当我们从远程仓库获取数据时, 远程分支也会更新以反映最新的远程仓库。</p>
<p>git fetch 完成了仅有的但是很重要的两步:</p>
<p>从远程仓库下载本地仓库中缺失的提交记录<br>更新远程分支指针(如 o&#x2F;main)<br>git fetch 实际上将本地仓库中的远程分支更新成了远程仓库相应分支最新的状态。</p>
<p>如果你还记得上一节课程中我们说过的，远程分支反映了远程仓库在你最后一次与它通信时的状态，git fetch 就是你与远程仓库通信的方式了！希望我说的够明白了，你已经了解 git fetch 与远程分支之间的关系了吧。</p>
<p>git fetch 通常通过互联网（使用 http:&#x2F;&#x2F; 或 git:&#x2F;&#x2F; 协议) 与远程仓库通信。</p>
<p>git fetch 不会做的事<br>git fetch 并不会改变你本地仓库的状态。它不会更新你的 main 分支，也不会修改你磁盘上的文件。</p>
<p>理解这一点很重要，因为许多开发人员误以为执行了 git fetch 以后，他们本地仓库就与远程仓库同步了。它可能已经将进行这一操作所需的所有数据都下载了下来，但是并没有修改你本地的文件。我们在后面的课程中将会讲解能完成该操作的命令 :D</p>
<p>所以, 你可以将 git fetch 的理解为单纯的下载操作。</p>
<h3 id="Git-Pull"><a href="#Git-Pull" class="headerlink" title="Git Pull"></a>Git Pull</h3><p>既然我们已经知道了如何用 git fetch 获取远程的数据, 现在我们学习如何将这些变化更新到我们的工作当中。</p>
<p>其实有很多方法的 —— 当远程分支中有新的提交时，你可以像合并本地分支那样来合并远程分支。也就是说就是你可以执行以下命令:</p>
<p>git cherry-pick o&#x2F;main<br>git rebase o&#x2F;main<br>git merge o&#x2F;main<br>等等<br>实际上，由于先抓取更新再合并到本地分支这个流程很常用，因此 Git 提供了一个专门的命令来完成这两个操作。它就是我们要讲的 git pull。</p>
<p>git pull 就是 git fetch 和 git merge 的缩写！，这里非常的精辟。</p>
<h3 id="模拟团队合作"><a href="#模拟团队合作" class="headerlink" title="模拟团队合作"></a>模拟团队合作</h3><p>这里作者开发了一个全新的命令git fakeTeamWork用来模拟远程仓库的变化</p>
<h3 id="Git-Push"><a href="#Git-Push" class="headerlink" title="Git Push"></a>Git Push</h3><p>OK，我们已经学过了如何从远程仓库获取更新并合并到本地的分支当中。这非常棒……但是我如何与大家分享我的成果呢？</p>
<p>嗯，上传自己分享内容与下载他人的分享刚好相反，那与 git pull 相反的命令是什么呢？git push！</p>
<p>git push 负责将你的变更上传到指定的远程仓库，并在远程仓库上合并你的新提交记录。一旦 git push 完成, 你的朋友们就可以从这个远程仓库下载你分享的成果了！</p>
<p>你可以将 git push 想象成发布你成果的命令。它有许多应用技巧，稍后我们会了解到，但是咱们还是先从基础的开始吧……</p>
<p>注意 —— git push 不带任何参数时的行为与 Git 的一个名为 push.default 的配置有关。它的默认值取决于你正使用的 Git 的版本，但是在教程中我们使用的是 upstream。 这没什么太大的影响，但是在你的项目中进行推送之前，最好检查一下这个配置。</p>
<h3 id="偏离的工作"><a href="#偏离的工作" class="headerlink" title="偏离的工作"></a>偏离的工作</h3><p>现在我们已经知道了如何从其它地方 pull 提交记录，以及如何 push 我们自己的变更。看起来似乎没什么难度，但是为何还会让人们如此困惑呢？</p>
<p>困难来自于远程库提交历史的偏离。</p>
<p>假设你周一克隆了一个仓库，然后开始研发某个新功能。到周五时，你新功能开发测试完毕，可以发布了。但是 —— 天啊！你的同事这周写了一堆代码，还改了许多你的功能中使用的 API，这些变动会导致你新开发的功能变得不可用。但是他们已经将那些提交推送到远程仓库了，因此你的工作就变成了基于项目旧版的代码，与远程仓库最新的代码不匹配了。</p>
<p>这种情况下, git push 就不知道该如何操作了。如果你执行 git push，Git 应该让远程仓库回到星期一那天的状态吗？还是直接在新代码的基础上添加你的代码，亦或由于你的提交已经过时而直接忽略你的提交？</p>
<p>因为这情况（历史偏离）有许多的不确定性，Git 是不会允许你 push 变更的。实际上它会强制你先合并远程最新的代码，然后才能分享你的工作。</p>
<p>那该如何解决这个问题呢？很简单，你需要做的就是使你的工作基于最新的远程分支。</p>
<p>有许多方法做到这一点呢，不过最直接的方法就是通过 rebase 调整你的工作。咱们继续，看看怎么 rebase！</p>
<p>我们用 git fetch 更新了本地仓库中的远程分支，然后用 rebase 将我们的工作移动到最新的提交记录下，最后再用 git push 推送到远程仓库。</p>
<p>还有其它的方法可以在远程仓库变更了以后更新我的工作吗? 当然有，我们还可以使用 merge</p>
<p>尽管 git merge 不会移动你的工作（它会创建新的合并提交），但是它会告诉 Git 你已经合并了远程仓库的所有变更。这是因为远程分支现在是你本地分支的祖先，也就是说你的提交已经包含了远程分支的所有变化。</p>
<p>我们用 git fetch 更新了本地仓库中的远程分支，然后合并了新变更到我们的本地分支（为了包含远程仓库的变更），最后我们用 git push 把工作推送到远程仓库</p>
<p>简化以上两种操作：<br>很好！但是要敲那么多命令，有没有更简单一点的？</p>
<p>当然 —— 前面已经介绍过 git pull 就是 fetch 和 merge 的简写，类似的 git pull –rebase 就是 fetch 和 rebase 的简写！</p>
<h3 id="远程服务器拒绝-Remote-Rejected"><a href="#远程服务器拒绝-Remote-Rejected" class="headerlink" title="远程服务器拒绝!(Remote Rejected)"></a>远程服务器拒绝!(Remote Rejected)</h3><p>如果你是在一个大的合作团队中工作, 很可能是main被锁定了, 需要一些Pull Request流程来合并修改。如果你直接提交(commit)到本地main, 然后试图推送(push)修改, 你将会收到这样类似的信息:</p>
<p>! [远程服务器拒绝] main -&gt; main (TF402455: 不允许推送(push)这个分支; 你必须使用pull request来更新这个分支.)<br>为什么会被拒绝?<br>远程服务器拒绝直接推送(push)提交到main, 因为策略配置要求 pull requests 来提交更新.</p>
<p>你应该按照流程,新建一个分支, 推送(push)这个分支并申请pull request,但是你忘记并直接提交给了main.现在你卡住并且无法推送你的更新.</p>
<p>解决办法<br>新建一个分支feature, 推送到远程服务器. 然后reset你的main分支和远程服务器保持一致, 否则下次你pull并且他人的提交和你冲突的时候就会有问题.</p>
<h2 id="git远程仓库高级操作"><a href="#git远程仓库高级操作" class="headerlink" title="git远程仓库高级操作"></a>git远程仓库高级操作</h2><h3 id="合并特性分支"><a href="#合并特性分支" class="headerlink" title="合并特性分支"></a>合并特性分支</h3><p>在大型项目中开发人员通常会在（从 main 上分出来的）特性分支上工作，工作完成后只做一次集成。这跟前面课程的描述很相像（把 side 分支推送到远程仓库），不过本节我们会深入一些.</p>
<p>但是有些开发人员只在 main 上做 push、pull —— 这样的话 main 总是最新的，始终与远程分支 (o&#x2F;main) 保持一致。</p>
<h3 id="为什么不用-merge-呢"><a href="#为什么不用-merge-呢" class="headerlink" title="为什么不用 merge 呢?"></a>为什么不用 merge 呢?</h3><p>为了 push 新变更到远程仓库，你要做的就是包含远程仓库中最新变更。意思就是只要你的本地分支包含了远程分支（如 o&#x2F;main）中的最新变更就可以了，至于具体是用 rebase 还是 merge，并没有限制。</p>
<p>那么既然没有规定限制，为何前面几节都在着重于 rebase 呢？为什么在操作远程分支时不喜欢用 merge 呢？</p>
<p>在开发社区里，有许多关于 merge 与 rebase 的讨论。以下是关于 rebase 的优缺点：</p>
<p>优点:</p>
<p>Rebase 使你的提交树变得很干净, 所有的提交都在一条线上<br>缺点:</p>
<p>Rebase 修改了提交树的历史<br>比如, 提交 C1 可以被 rebase 到 C3 之后。这看起来 C1 中的工作是在 C3 之后进行的，但实际上是在 C3 之前。</p>
<p>一些开发人员喜欢保留提交历史，因此更偏爱 merge。而其他人（比如我自己）可能更喜欢干净的提交树，于是偏爱 rebase。仁者见仁，智者见智。</p>
<h3 id="远程跟踪分支"><a href="#远程跟踪分支" class="headerlink" title="远程跟踪分支"></a>远程跟踪分支</h3><p>在前几节课程中有件事儿挺神奇的，Git 好像知道 main 与 o&#x2F;main 是相关的。当然这些分支的名字是相似的，可能会让你觉得是依此将远程分支 main 和本地的 main 分支进行了关联。这种关联在以下两种情况下可以清楚地得到展示：</p>
<p>pull 操作时, 提交记录会被先下载到 o&#x2F;main 上，之后再合并到本地的 main 分支。隐含的合并目标由这个关联确定的。<br>push 操作时, 我们把工作从 main 推到远程仓库中的 main 分支(同时会更新远程分支 o&#x2F;main) 。这个推送的目的地也是由这种关联确定的！</p>
<p>直接了当地讲，main 和 o&#x2F;main 的关联关系就是由分支的“remote tracking”属性决定的。main 被设定为跟踪 o&#x2F;main —— 这意味着为 main 分支指定了推送的目的地以及拉取后合并的目标。</p>
<p>你可能想知道 main 分支上这个属性是怎么被设定的，你并没有用任何命令指定过这个属性呀！好吧, 当你克隆仓库的时候, Git 就自动帮你把这个属性设置好了。</p>
<p>当你克隆时, Git 会为远程仓库中的每个分支在本地仓库中创建一个远程分支（比如 o&#x2F;main）。然后再创建一个跟踪远程仓库中活动分支的本地分支，默认情况下这个本地分支会被命名为 main。</p>
<p>克隆完成后，你会得到一个本地分支（如果没有这个本地分支的话，你的目录就是“空白”的），但是可以查看远程仓库中所有的分支（如果你好奇心很强的话）。这样做对于本地仓库和远程仓库来说，都是最佳选择。</p>
<p>这也解释了为什么会在克隆的时候会看到下面的输出：</p>
<p>local branch “main” set to track remote branch “o&#x2F;main”</p>
<p>我能自己指定这个属性吗？<br>当然可以啦！你可以让任意分支跟踪 o&#x2F;main, 然后该分支会像 main 分支一样得到隐含的 push 目的地以及 merge 的目标。 这意味着你可以在分支 totallyNotMain 上执行 git push，将工作推送到远程仓库的 main 分支上。</p>
<p>有两种方法设置这个属性，第一种就是通过远程分支切换到一个新的分支，执行:</p>
<p>git checkout -b totallyNotMain o&#x2F;main</p>
<p>就可以创建一个名为 totallyNotMain 的分支，它跟踪远程分支 o&#x2F;main。</p>
<p>第二种方法<br>另一种设置远程追踪分支的方法就是使用：git branch -u 命令，执行：</p>
<p>git branch -u o&#x2F;main foo</p>
<p>这样 foo 就会跟踪 o&#x2F;main 了。如果当前就在 foo 分支上, 还可以省略 foo：</p>
<p>git branch -u o&#x2F;main</p>
<h3 id="Git-Push-的参数"><a href="#Git-Push-的参数" class="headerlink" title="Git Push 的参数"></a>Git Push 的参数</h3><p>既然你知道了远程跟踪分支，我们可以开始揭开 git push、fetch 和 pull 的神秘面纱了。我们会逐个介绍这几个命令，它们在理念上是非常相似的。</p>
<p>首先来看 git push。在远程跟踪课程中，你已经学到了 Git 是通过当前所在分支的属性来确定远程仓库以及要 push 的目的地的。这是未指定参数时的行为，我们可以为 push 指定参数，语法是：</p>
<p>git push &lt; remote &gt; &lt; place &gt;</p>
<p>&lt; place &gt; 参数是什么意思呢？我们稍后会深入其中的细节, 先看看例子, 这个命令是:</p>
<p>git push origin main</p>
<p>把这个命令翻译过来就是：</p>
<p>切到本地仓库中的“main”分支，获取所有的提交，再到远程仓库“origin”中找到“main”分支，将远程仓库中没有的提交记录都添加上去，搞定之后告诉我。</p>
<p>我们通过“place”参数来告诉 Git 提交记录来自于 main, 要推送到远程仓库中的 main。它实际就是要同步的两个仓库的位置。</p>
<p>需要注意的是，因为我们通过指定参数告诉了 Git 所有它需要的信息, 所以它就忽略了我们所切换分支的属性！</p>
<h3 id="Git-Push-的参数2"><a href="#Git-Push-的参数2" class="headerlink" title="Git Push 的参数2"></a>Git Push 的参数2</h3><p>&lt; place &gt;参数详解<br>还记得之前课程说的吧，当为 git push 指定 place 参数为 main 时，我们同时指定了提交记录的来源和去向。</p>
<p>你可能想问 —— 如果来源和去向分支的名称不同呢？比如你想把本地的 foo 分支推送到远程仓库中的 bar 分支。</p>
<p>哎，很遗憾 Git 做不到…… 开个玩笑，别当真！当然是可以的啦 :) Git 拥有超强的灵活性（有点过于灵活了）</p>
<p>要同时为源和目的地指定 &lt; place &gt; 的话，只需要用冒号 : 将二者连起来就可以了：</p>
<p>git push origin &lt; source &gt;:&lt; destination &gt;</p>
<p>这个参数实际的值是个 refspec，“refspec” 是一个自造的词，意思是 Git 能识别的位置（比如分支 foo 或者 HEAD~1）</p>
<p>一旦你指定了独立的来源和目的地，就可以组织出言简意赅的远程操作命令了.</p>
<p>如果你要推送到的目的分支不存在会怎么样呢？没问题！Git 会在远程仓库中根据你提供的名称帮你创建这个分支！</p>
<h3 id="Git-fetch-的参数"><a href="#Git-fetch-的参数" class="headerlink" title="Git fetch 的参数"></a>Git fetch 的参数</h3><p>我们刚学习了 git push 的参数，很酷的 &lt; place&gt; 参数，还有用冒号分隔的 refspecs（&lt; source &gt;:&lt; destination &gt;）。 这些参数可以用于 git fetch 吗？</p>
<p>你猜中了！git fetch 的参数和 git push 极其相似。他们的概念是相同的，只是方向相反罢了（因为现在你是下载，而非上传）</p>
<p>&lt; place &gt; 参数<br>如果你像如下命令这样为 git fetch 设置 的话：</p>
<p>git fetch origin foo</p>
<p>Git 会到远程仓库的 foo 分支上，然后获取所有本地不存在的提交，放到本地的 o&#x2F;foo 上。</p>
<p>你可能会好奇 —— 为何 Git 会将新提交放到 o&#x2F;foo 而不是放到我本地的 foo 分支呢？之前不是说这样的 参数就是同时应用于本地和远程的位置吗？</p>
<p>好吧, 本例中 Git 做了一些特殊处理，因为你可能在 foo 分支上的工作还未完成，你也不想弄乱它。还记得在 git fetch 课程里我们讲到的吗 —— 它不会更新你的本地的非远程分支, 只是下载提交记录（这样, 你就可以对远程分支进行检查或者合并了）。</p>
<p>“如果我们指定 &lt; source &gt;:&lt; destination &gt; 会发生什么呢？”</p>
<p>如果你觉得直接更新本地分支很爽，那你就用冒号分隔的 refspec 吧。不过，你不能在当前切换的分支上干这个事，但是其它分支是可以的。</p>
<p>这里有一点是需要注意的 —— source 现在指的是远程仓库中的位置，而 &lt; destination &gt; 才是要放置提交的本地仓库的位置。它与 git push 刚好相反，这是可以讲的通的，因为我们在往相反的方向传送数据。</p>
<p>理论上虽然行的通，但开发人员很少这么做。我在这里介绍它主要是为了从概念上说明 fetch 和 push 的相似性，只是方向相反罢了。</p>
<p>跟 git push 一样，Git 会在 fetch 前自己创建立本地分支, 就像是 Git 在 push 时，如果远程仓库中不存在目标分支，会自己在建立一样。</p>
<h3 id="古怪的-lt-source-gt"><a href="#古怪的-lt-source-gt" class="headerlink" title="古怪的 &lt; source &gt;"></a>古怪的 &lt; source &gt;</h3><p>Git 有两种关于 &lt; source &gt; 的用法是比较诡异的，即你可以在 git push 或 git fetch 时不指定任何 source，方法就是仅保留冒号和 destination 部分，source 部分留空。</p>
<p>git push origin :side，它会删除远程仓库中的分支！<br>git fetch origin :bugFix，如果 fetch 空 到本地，会在本地创建一个新分支。</p>
<h3 id="Git-pull-参数"><a href="#Git-pull-参数" class="headerlink" title="Git pull 参数"></a>Git pull 参数</h3><p>既然你已经掌握关于 git fetch 和 git push 参数的方方面面了，关于 git pull 几乎没有什么可以讲的了 :)</p>
<p>因为 git pull 到头来就是 fetch 后跟 merge 的缩写。你可以理解为用同样的参数执行 git fetch，然后再 merge 你所抓取到的提交记录。</p>
<p>以下命令在 Git 中是等效的:</p>
<p>git pull origin foo 相当于：</p>
<p>git fetch origin foo; git merge o&#x2F;foo</p>
<p>还有…</p>
<p>git pull origin bar~1:bugFix 相当于：</p>
<p>git fetch origin bar~1:bugFix; git merge bugFix</p>
<p>看到了? git pull 实际上就是 fetch + merge 的缩写, git pull 唯一关注的是提交最终合并到哪里（也就是为 git fetch 所提供的 destination 参数）</p>
]]></content>
      <categories>
        <category>编程学习笔记</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>完结</tag>
      </tags>
  </entry>
  <entry>
    <title>日常一些碎碎念（不定时更新）</title>
    <url>/2023/08/28/%E6%97%A5%E5%B8%B8%E4%B8%80%E4%BA%9B%E7%A2%8E%E7%A2%8E%E5%BF%B5/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>记录平时的一些碎碎念，当时所想只是一种情感，一种激情，可能并不正确，但对这些情感的快照，留存于此，对我而言，弥足珍贵。<br>因为本博客，还是以IT技术为主，所以这类信息就全部存放在此，以保证博客的简洁。<br>记录的碎碎念，按栈的理论，先进后出，也就是时间倒序的排列。<br>下面是正文。</p>
<span id="more"></span>
<h1 id="正文（时间倒序排列）"><a href="#正文（时间倒序排列）" class="headerlink" title="正文（时间倒序排列）"></a>正文（时间倒序排列）</h1><h2 id="使用番茄时钟的意义"><a href="#使用番茄时钟的意义" class="headerlink" title="使用番茄时钟的意义"></a>使用番茄时钟的意义</h2><p>番茄时钟旨在帮助计划能够顺利进行，但是我常遇到这样的情况，就是我爽的飞起干这件事，番茄时钟却要求你停下休息，以为了能够跑得更久。这种想法在很多的娱乐产品，如大型的单机游戏，跌宕起伏的电影，都需要这种，休息，冲刺，休息，冲刺。包括健身，都会按组来做锻炼，而不会一直疯狂做。<br>这些想法非常好，但是无法解释，为什么我可以玩游戏一整天而不累，真的在休息的途中，我没有玩么？不，我一直玩，我从早上玩到晚上。这里的变量是兴趣，我们需要的是番茄时钟干不喜欢的事情。只有干不喜欢的事情我们才会渴望休息。如果这个事情你无比喜欢，你是不会考虑休息，你会进入心流，这是休息反而是一种坏处，一种干扰，一种必须被抛弃的概念。<br>所以使用番茄时钟进入佳境，就应该丢掉它，它会影响我们进入最里面的深度。除非你不喜欢，需要来个大长跑，实际上，自己可以感觉到自己的疲劳，这个时候，需要的是一杯咖啡，继续前伸，然后不行，我们休息总结。<br>一次深入的交流，好过多次表面功夫，这样可以更顺利的帮助计划的进行。</p>
<h2 id="终结，起始，当下"><a href="#终结，起始，当下" class="headerlink" title="终结，起始，当下"></a>终结，起始，当下</h2><p>终结所有一切的思绪，沉浸在当下，沉浸在此时的快乐，是无负担，开心的享受。<br>人需先自爱，方可教人爱你，当下，就是自爱的体现。<br>宗教徒的祷告，之所以充满力量温暖人心，是在无上之高的交流当中感受到了宁静，心灵归属了寄托。<br>所以爱上帝和爱自己统一，信教者往往快乐充实。<br>然而自己也有这本能的力量，就是沉浸于当下，沉浸于当下需要首先终结起始的意识，起始的意识，是待发动的意思。<br>只有无意识于当下，就是对内心的祷告。是内心的平静和安宁。<br>这是一种有品质的生活态度，有品质的评价是对自爱的体现。<br>是自爱在我身上的衍生，人们寻觅太多，而常常缺视自身，这并不平衡。</p>
<h2 id="静坐于呼吸当中的两极体悟"><a href="#静坐于呼吸当中的两极体悟" class="headerlink" title="静坐于呼吸当中的两极体悟"></a>静坐于呼吸当中的两极体悟</h2><p>烦躁，焦虑，悲伤，自傲，疲惫，等等负面情绪，通过静坐可以得到充分的缓解，因为静坐在安静的环境之下，清净了五官，缓解了四肢。我在静坐当中不仅可以感受到呼吸的频率，还可以感受到心脏的跳动，伴随的心脏的跳动，内部蹦蹦的活力。全身心沉浸在安谧，就会感觉到两极的变化，比如骄傲，就要谦虚，比如焦虑，就要放松，比如悲伤，就要乐观，比如烦躁，就要平静。周身的中正，内心的中正，奇妙，奇妙。</p>
<h2 id="成长的可行性"><a href="#成长的可行性" class="headerlink" title="成长的可行性"></a>成长的可行性</h2><p>成长是否是会在一瞬间停止，成长又会在那一刻生长？这取决于名的概念。如果是因为外在环境的变化，那么成长也会发生，但那只是表象的变化，是实对名。就其本身而言，本我的名从来没有考究过自己的成长，属于阶段性的适应性成长，是会在适应的环境的磨合期当中停止成长，这个人就会保留在此之前的全部。在意识层面的名上已经暂停生长，成为了一个僵硬的人，一个封闭的人。我所指的成长可行性是意识层面成长，是内心的成长，这种成长不是适应环境的被动成长。是一种主动的有所指向的成长，而在这过程当中，绝大部分人都忽视了成长的可行性这个方面。<br>自我的成长固然重要，但是不对环境，终究还是回归环境，成长的过程要和成长的可行性等长，两种应该是一种交互的方式，只要有成长的可行性这个方向的指引，成长就会在它的环境的空间内生长。对此苏格拉底有很深的感悟，他说过“我是智慧的接生者”这句话就点名了这一点。成长对于个人是不一样的意义，哪怕苏格拉底都喜欢和不同人交谈，对他而言，他的弟子而言，这是一种获得智慧的方式。通过交流介入别人成长可行性来指导成长本身的过程，是互相交互共同成就成长的过程。<br>在一个可行性的指引下，成长会缓慢发生，他将引导人往变化的方向的发展，至于好或者坏的结果，我们无法预言，能知道的是这条路可以继续走，最怕的是走无可走，那就意味着的成长可行性的凋亡，自身的固定，自身的僵化，是自我对现状的满足，成长也就再次回归到他字面上的意义，从个人的名当中剔去了，也变成我们平常的语言。成长和长大两个词语，你若不仔细看将再你身上没有任何差别，你就将就此成为你。</p>
<h2 id="完美存在于概念"><a href="#完美存在于概念" class="headerlink" title="完美存在于概念"></a>完美存在于概念</h2><p>完美是存在的，但是它不存在于实际之中，也就是说没有完美的物品，因为完美没有标准，完美引向了全知全能的趋势。如果一个事物完美，其实它并不完美，它只是达标而已，因为达到预期及其以上的程度所以称为完美，其实是很不错的主观判断。而完美一词具有迷惑性，它和主观的判断有着某种割裂，仿佛脱离了判断这个完美的人还是完美的一样。那它就不完美了，所以完美是存在于概念当中的事物，现实事物的评价，只有标准的符合的程度。而没有完美这个没有刻度的主观评价的属性的存在。完美只有个体的惊叹，而没有事物的准确的描述。<br>如果有如实描述完美，就有说出标准，没有说出标准的完美而称为完美，是他人的主观完美转移到了事物之上，被人赋予的完美。人人觉得完美的事物，归根到底还是事物本身，事物本身是会变化，如果这样来看完美更是一种暂时性质的快照。更反映出符合一个标准之上的预期判断，可能自己都没有意识到自知的标准，就称呼其为完美。<br>所以了解完美的事物，就是了解赋予完美事物的人的观念。完美只存在于概念之中，是一个个体那瞬间的惊叹。</p>
<h2 id="简略思考到行动"><a href="#简略思考到行动" class="headerlink" title="简略思考到行动"></a>简略思考到行动</h2><p>过度的思考反思到事物的名当中是一个费神的功夫，这一过程通常没有确切的目的和诉求，是其本身发散的组合，所以快速的思考，缓慢的拼凑可能性，但是没有终止的条件。因为这一过程的本质是追求最优解。而如果沉迷于其中往往得不偿失，空耗精神而无所得，会顾此失彼。<br>因此为了简略的思考，快乐的生活，需要简化这一思考的流程。需要得出能够实践的结论，应该率先提炼出来，然后就到终止条件，可以提前跳出这一不断完善的过程了。空空耗神的时间也是实践过程的成本，这不可估量。<br>需要的路可能不是最优美的一条，但是胜在可以走的更远，这一前提会让人变得更加的果敢一些。可以很快的得出结论，然后行动，创造突破口，添加筹码，迅速迭代，从而更加切合实际，毕竟名不能太过高于实了，那就变成了痴人说梦。</p>
<h2 id="语言欲演自身"><a href="#语言欲演自身" class="headerlink" title="语言欲演自身"></a>语言欲演自身</h2><p>语言是文化的载体，知道语言就可以知道其内在的力量。<br>语言会影响自身，语言会塑造自身。<br>少说多做，少想多做，少思多做，在行动中把语言转换为力量，语言的背后是潜在的名，未有实现的实在力量。被其影响，就会变成其样。<br>所有人在为受影响之前，应该是白洁污垢之人，有了影响之后，就有了实在当中的所在定位。所有的一切额外附加，在生下来的时候就已经决定。</p>
<h2 id="外在环境是必要的"><a href="#外在环境是必要的" class="headerlink" title="外在环境是必要的"></a>外在环境是必要的</h2><p>虚无者在存在的过程当中，是静止不动的。<br>也就是死寂，但是这个情况属于假的死寂。<br>我理解的真的死寂，应该是和个体一样的精神死亡一样，彻底和外在脱节。<br>而虚无者还和外界是有关联的，所以跟我定义的死寂是差一步之遥。<br>所以我希望可以和英文一样加个ing估计好理解一点，死寂ing。<br>但是在这里，我称作为假的死寂。<br>因为是不完全的死寂，还和外界存在的交互。<br>或多或少会被外在冲击，所以会产生自我和外在的矛盾。这种矛盾的产生就是”非我”的因素，客观的实在在冲击自己。<br>想要精神的绝对自由因此不可能存在，外在的实在始终存在，无法脱离外在而独存，就是一个明证。<br>所以我希望撞到南墙就回头，虚无者应该变成积极者，外在实在就会带你走向另外一个道路。但是如果本身没有过虚无者念头的实现，就没有很清楚的分别”我”和”非我”，因为在现实实际当中，两者是互相包裹的，难以分开。自杀者之所以会选择自我肉体毁灭的想法，就是想试图赶走”非我”的存在，一了百了，是一种抛离的方式，一种取消问题本身的方法。<br>而虚无者比自杀者的高明在于直接对抗这外在的实在，试图分离”我”和”非我”，亦或者是和解”我”和”非我”，所以就会产生这样一个极端的两极反转，从消极的虚无变成积极的虚无，进而会开启全新的视野去看待外在事物，看待”非我”，一睡一醒之间就换了人间。这里之所以用积极的虚无就是说明本质并没有发生改变，发生改变的是因对外在的行为，这里存在的不确定性，只要这个虚无者愿意，他随时可以再一次进行对抗，直到他认可为止。<br>这里让我想到了尼采构想超越人的的全新物种–超人。如何成为超人，可能就有这么一条路径很有可能就是通过这种类似的方式来进行获取的，而语言文字是有其存在的上限，因此无法用语言来完全完整的表述获取的东西，也就是会成为外人看来的另类者或者境界高的人的原因，因为他的本身是发散的太阳，他的道理说不尽道不完，而又因为每一个在成为虚无者之前，他们本身都是不一样的存在，所以他们本身发散的太阳也是互相不一样的。世界上没有两个相同的两片叶子，也没有两个相同的人，我只能成为”我”。</p>
<h2 id="对虚无者凝视虚无的呻吟"><a href="#对虚无者凝视虚无的呻吟" class="headerlink" title="对虚无者凝视虚无的呻吟"></a>对虚无者凝视虚无的呻吟</h2><p>这是一首悲歌，凄惨，黑暗，无助的逝去。<br>没有任何意义是一个毒药，会毒害存在本身。<br>没有意义，空有虚无，唯有永恒。<br>四肢陌生，五官无感，脱离尘世。</p>
<h2 id="“我”的意义"><a href="#“我”的意义" class="headerlink" title="“我”的意义"></a>“我”的意义</h2><p>“我”的概念是凝视出来的产物。<br>如果没有，或者被现代的科技如短视频之类的蒙蔽了”我”。<br>那么没有”我”的人，是被沉沦的对象。<br>如果有了”我”就有了痛苦和快乐，就有了与实在世界的接触。<br>这个接触可以让”我”有血有肉，不要忘记这种感觉，那是”我”在活着。<br>古人和今人相比更加容易保持这种状态，因为它们缺少干扰，就能在”我”的基础上抒发志向，淳淳而行。今人则不同，”我”的缺位，让”我”长期成为沉沦的对象”它”代入有意义或无意义非”我”的主体对象，是主体的错位。这种错位会让人空洞化，标签化，是我非”我”。<br>就我个人体验而言，在我身上比重极大，是”我”长期变成”它”的无力的，快活的，乌托邦似的，空虚的，荒诞的，之其以前孩提就存在而无法描述的感觉，现在得以描述，对我而言是名有所实指，需要时常温习，不能忘”我”。<br>这里反问我一句来凝视自身：“你真心实切的想好你正在成为什么了么？”。</p>
<h2 id="凝视的意义"><a href="#凝视的意义" class="headerlink" title="凝视的意义"></a>凝视的意义</h2><p>凝视是这样到来的，我拥有这样一个图景，一个暗淡的天空笼罩镜面般的湖泊，而我悬浮在湖泊的椅子上看的镜面般的湖泊。<br>在这个意像当中我看到的只有我自己，孤独自处。<br>就会想变得优雅，在无人之中，保持规律。<br>因为对视，所以产生了意图。<br>自我也在此产生。<br>我有了实体，就会凝视别的含义，看向远处。</p>
<h2 id="未来态"><a href="#未来态" class="headerlink" title="未来态"></a>未来态</h2><p>很少感觉到的激情在我沉寂已久心理的迸发出来，这是我继感受名与实的困惑又一次的超越。<br>我觉得未来态，将会出现，这将是我所求的一个生活态度。</p>
<p>未来态是一种创新和变革的未来主义，拥抱他的人将会拥有全新的生活态度。<br>这种生活态度，这种状态，我称之为未来态。<br>以一种全新开放的态度迎接未来生活。<br>第一就是信息的完备，信息是未来态这种生活态度的基石，没有充足的信息，就无法正确的理解事物。<br>第二是理解信息，如果不能够处理繁多的信息，就会提炼不出未来态。<br>第三是建立图景，要便捷的绘画在脑内，在多种感官，在繁多当中找到自己最喜欢的模型，最优美的图案。<br>第四是选择，这将是最煎熬的时刻，意味着你将踏入未来态。<br>第五是理所当然的行动。</p>
<h2 id="名与实的暂叙"><a href="#名与实的暂叙" class="headerlink" title="名与实的暂叙"></a>名与实的暂叙</h2><p>1.名是实的发生<br>2.实是名的依存<br>3.名和实在纵向是起点和终点的图景<br>其中的指引便是对于图景的连接，这是一种超出常人的预示，也只有预示才可以指引现实。<br>4.对于图景的选择：<br>图景的选择是对于信息的压缩。<br>画面的中断是存在的前进，是一种画面的帧。  </p>
]]></content>
      <categories>
        <category>碎碎念</category>
      </categories>
      <tags>
        <tag>碎碎念</tag>
        <tag>哲思随笔</tag>
        <tag>不定时更新</tag>
      </tags>
  </entry>
</search>
