<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>学习git的叙述（长期更新）</title>
    <url>/2023/08/22/%E5%AD%A6%E4%B9%A0git%E7%9A%84%E5%8F%99%E8%BF%B0/</url>
    <content><![CDATA[<h1 id="前言说明"><a href="#前言说明" class="headerlink" title="前言说明"></a>前言说明</h1><p>根据以下资料自学，</p>
<ul>
<li><a href="https://backlog.com/git-tutorial/cn/">猴子都能懂的Git入门</a>（完成）</li>
<li><a href="https://learngitbranching.js.org/?locale=zh_CN">Learning Git Branching 在线游戏</a>(在玩)</li>
<li><a href="https://docs.github.com/zh/get-started">GitHub 入门文档</a>（待学）</li>
<li><a href="https://github.phodal.com/#/">GitHub 漫游指南</a>（待学）</li>
<li><a href="https://oschina.gitee.io/opensource-guide/">开源指北</a>（待学）</li>
<li><a href="https://git-scm.com/book/zh/v2">Git官方文档</a>（待学）</li>
<li><a href="https://docs.github.com/zh">GitHub官方文档</a>（待学）<span id="more"></span></li>
</ul>
<h1 id="内容叙述–猴子都能懂的Git入门（已完结）"><a href="#内容叙述–猴子都能懂的Git入门（已完结）" class="headerlink" title="内容叙述–猴子都能懂的Git入门（已完结）"></a>内容叙述–猴子都能懂的Git入门（已完结）</h1><h2 id="首先"><a href="#首先" class="headerlink" title="首先"></a>首先</h2><p>Git是一个分布式版本管理系统，是为了更好地管理Linux内核开发而创立的。<br>用Git管理文件，更新的历史会保存在Git。<br>如果和别人共享文件修改时有冲突，会发出报错警告。  </p>
<h2 id="Git的数据库"><a href="#Git的数据库" class="headerlink" title="Git的数据库"></a>Git的数据库</h2><p>数据库 (Repository) 是记录文件或目录状态的地方，存储着内容修改的历史记录。<br>Git的数据库分为远程数据库和本地数据库的两种。<br>远程数据库和本地数据库的交流为pull和push。<br>其中：创建本地数据库的方法有两种：一种是创建全新的数据库，另一种是复制远程数据库。<br>提交到远程数据库为了方便协同合作，务必输入准确简洁的提交信息，遵循下列Git的标准注解原则：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">第1行：提交修改内容的摘要</span><br><span class="line">第2行：空行</span><br><span class="line">第3行以后：修改的理由</span><br></pre></td></tr></table></figure>

<h2 id="工作树和索引"><a href="#工作树和索引" class="headerlink" title="工作树和索引"></a>工作树和索引</h2><p>在Git管理下，大家实际操作的目录被称为工作树。<br>在数据库和工作树之间有索引，索引是为了向数据库提交作准备的区域。<br>凭借中间的索引，可以避免工作树中不必要的文件提交，还可以将文件修改内容的一部分加入索引区域并提交。</p>
<h2 id="实操的提前准备"><a href="#实操的提前准备" class="headerlink" title="实操的提前准备"></a>实操的提前准备</h2><p>首先安装<a href="http://msysgit.github.io/">git</a>，再安装开放源代码的Git客户端<a href="http://code.google.com/p/tortoisegit/">TortoiseGit</a>（有官方汉化语言包）。</p>
<h2 id="版本库，工作树，暂存区"><a href="#版本库，工作树，暂存区" class="headerlink" title="版本库，工作树，暂存区"></a>版本库，工作树，暂存区</h2><p>版本库（Repository）： 在Git中，版本库是存储代码历史记录的地方。它包括了整个项目的历史状态、分支、标签等信息。当你执行git init命令创建一个新的版本库时，Git会在你的项目文件夹中生成一个名为.git的隐藏文件夹，这个文件夹就是版本库。</p>
<p>工作树（Working Tree）： 工作树是你项目文件夹中的实际文件和文件夹，它反映了你当前的工作状态。在工作树中进行的文件修改、添加、删除等操作都会被记录下来，然后可以通过提交到版本库来保留这些修改。</p>
<p>暂存区（Staging Area）： 暂存区是位于版本库和工作树之间的一个缓冲区域。当你使用git add命令将文件添加到暂存区时，你正在告诉Git这些文件将会被包含在下一次的提交中。</p>
<p>在操作过程中，文件会从工作树添加到暂存区，然后再从暂存区提交到版本库中。这种分层结构使得Git能够记录代码的变更历史并支持版本控制。</p>
<h2 id="解决冲突"><a href="#解决冲突" class="headerlink" title="解决冲突"></a>解决冲突</h2><p>当前一个数据和后一个数据冲突，需要对手动来解决冲突，我们首先需要pull，得到远程别人最新的修改版本，到本地来对照自己的版本，解决冲突之后再上传push。</p>
<h2 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h2><p>分支是为了将修改记录的整体流程分叉保存。分叉后的分支不受其他分支的影响，所以在同一个数据库里可以同时进行多个修改。<br>为了不受其他开发人员的影响，您可以在主分支上建立自己专用的分支。完成工作后，将自己分支上的修改合并到主分支。因为每一次提交的历史记录都会被保存，所以当发生问题时，定位和修改造成问题的提交就容易多了。</p>
<h3 id="常见的两种分支形式"><a href="#常见的两种分支形式" class="headerlink" title="常见的两种分支形式"></a>常见的两种分支形式</h3><p>Merge分支是为了可以随时发布release而创建的分支，它还能作为Topic分支的源分支使用。保持分支稳定的状态是很重要的。通常，大家会将master分支当作Merge分支使用。</p>
<p>Topic分支是为了开发新功能或修复Bug等任务而建立的分支。若要同时进行多个的任务，请创建多个的Topic分支。Topic分支是从稳定的Merge分支创建的。完成作业后，要把Topic分支合并回Merge分支。</p>
<h3 id="分支的切换"><a href="#分支的切换" class="headerlink" title="分支的切换"></a>分支的切换</h3><p>若要切换作业的分支，就要进行checkout操作。进行checkout时，git会从工作树还原向目标分支提交的修改内容。checkout之后的提交记录将被追加到目标分支。<br>这里需要注意的是，还原的是git本地的，工作区和暂存区，还原之后，就会把版本库和工作树切换到全新的分支。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git checkout -b branchB #-b的参数是branch的意思</span><br><span class="line">git checkout branchB #这里是切换到branchB，如果没有需要加-b参数，切换并创建</span><br></pre></td></tr></table></figure>

<h3 id="head指针"><a href="#head指针" class="headerlink" title="head指针"></a>head指针</h3><p>涉及到分支的切换，就需要了解head的指针，HEAD指向的是现在使用中的分支的最后一次更新。通常默认指向master分支的最后一次更新。通过移动HEAD，就可以变更使用的分支。</p>
<blockquote>
<p>举一个例子：<br>假设你有一个提交历史记录 A -&gt; B -&gt; C -&gt; D -&gt; E，并且”HEAD” 当前指向 E。</p>
</blockquote>
<blockquote>
<p>如果你想要创建一个新的分支 B2，可以使用 git checkout -b B2 命令。这会在 E 的位置创建一个新分支 B2，然后将”HEAD” 移动到 B2，意味着你在 B2 分支上开始了新的工作。</p>
</blockquote>
<blockquote>
<p>如果你想要将版本回退到 C，你可以使用 git reset –hard C 命令。这将会让”HEAD” 和当前分支都指向 C，你的工作树和暂存区也会被还原为 C 的状态。</p>
</blockquote>
<blockquote>
<p>通过切换分支或回退版本，”HEAD” 会移动到不同的提交位置，指向不同的分支或提交。</p>
</blockquote>
<h3 id="stash操作"><a href="#stash操作" class="headerlink" title="stash操作"></a>stash操作</h3><p>还未提交的修改内容以及新添加的文件，留在索引区域或工作树的情况下切换到其他的分支时，修改内容会从原来的分支移动到目标分支。<br>但是如果在checkout的目标分支中相同的文件也有修改，checkout会失败的。这时要么先提交修改内容，要么用stash暂时保存修改内容后再checkout。<br>stash是临时保存文件修改内容的区域。stash可以暂时保存工作树和索引里还没提交的修改内容，您可以事后再取出暂存的修改，应用到原先的分支或其他的分支上。<br>总结：”stash” 在Git中指的是暂时隐藏未提交修改的操作，使你可以在不提交修改的情况下进行其他操作。</p>
<h2 id="分支的合并"><a href="#分支的合并" class="headerlink" title="分支的合并"></a>分支的合并</h2><p>合并分支有2种方法：使用merge或rebase</p>
<h3 id="merge"><a href="#merge" class="headerlink" title="merge"></a>merge</h3><p>merge合并是将一个分支的更改合并到另一个分支的常见方法。合并创建一个新的提交，将两个分支的更改整合到一起。合并提交将会有多个父提交，分别来自于要合并的两个分支。这种方法适用于保留分支历史，使每个分支的更改都能够清楚地追踪。</p>
<h3 id="rebase"><a href="#rebase" class="headerlink" title="rebase"></a>rebase</h3><p>Rebase变基是另一种将分支更改整合的方法，它的目标是创建一个线性的提交历史，使分支看起来像是连续的。在变基过程中，你从一个分支 “复制” 更改，然后将它们 “粘贴” 到另一个分支的末尾。这使得提交历史看起来更干净，但也可能会改变提交的顺序和提交的 SHA 标识。</p>
<p>总结区别：<br>Merge 会创建一个合并提交，它反映了分支间的合并。<br>Rebase 会将源分支的更改逐个应用到目标分支的末尾，形成一个线性的提交历史。</p>
<h3 id="git分支的应用"><a href="#git分支的应用" class="headerlink" title="git分支的应用"></a>git分支的应用</h3><p>点击查看Vincent Driessen大佬的博文<a href="http://nvie.com/posts/a-successful-git-branching-model/">A successful Git branching model</a><br>阅读原文推荐浏览器插件沙拉查词，或则使用欧路词典eudic。<br>作者在时间的推移当中，划分了五个不同类型的branch。<br>类型1：master，主类型，起label的作用，确定档号，最稳定版。    </p>
<blockquote>
<p>作者原话摘抄：We consider origin&#x2F;master to be the main branch where the source code of HEAD always reflects a production-ready state.  </p>
</blockquote>
<p>类型2：hotfixes，紧急类型，起熬夜加班修bug类型,修完之后需要立刻更新到其他develop和master分支上。   </p>
<blockquote>
<p>Hotfix branches are very much like release branches in that they are also meant to prepare for a new production release, albeit unplanned. They arise from the necessity to act immediately upon an undesired state of a live production version. When a critical bug in a production version must be resolved immediately, a hotfix branch may be branched off from the corresponding tag on the master branch that marks the production version.</p>
</blockquote>
<blockquote>
<p>The one exception to the rule here is that, when a release branch currently exists, the hotfix changes need to be merged into that release branch, instead of develop. Back-merging the bugfix into the release branch will eventually result in the bugfix being merged into develop too, when the release branch is finished. (If work in develop immediately requires this bugfix and cannot wait for the release branch to be finished, you may safely merge the bugfix into develop now already as well.)</p>
</blockquote>
<p>类型3：release branches，主要发行版，大部分人使用。<br>类型4：develop ，主要开发者版本，开发者使用通行版，最终要回归master。   </p>
<blockquote>
<p>作者原话摘抄：We consider origin&#x2F;develop to be the main branch where the source code of HEAD always reflects a state with the latest delivered development changes for the next release. Some would call this the “integration branch”. This is where any automatic nightly builds are built from.  </p>
</blockquote>
<p>类型5：feature branches，特性开发版本，这里可以允许开发者扩展多个分支，同时开发多种特性。    </p>
<blockquote>
<p>作者原话摘抄：Feature branches (or sometimes called topic branches) are used to develop new features for the upcoming or a distant future release. When starting development of a feature, the target release in which this feature will be incorporated may well be unknown at that point. The essence of a feature branch is that it exists as long as the feature is in development, but will eventually be merged back into develop (to definitely add the new feature to the upcoming release) or discarded (in case of a disappointing experiment).</p>
</blockquote>
<p>细节方面：<br>在某一个feature branch开发完成后，需要这样回归</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git chekout feature </span><br><span class="line">#Switched to branch &#x27;develop&#x27;</span><br><span class="line">git merge --no-ff myfeature </span><br><span class="line">#Updating ea1b82a..05e9557</span><br><span class="line">git branch -d myfeature </span><br><span class="line">#Deleted branch myfeature (was 05e9557).</span><br><span class="line">git push origin develop </span><br><span class="line">#从本地上传</span><br></pre></td></tr></table></figure>
<p>这里的合并使用了 git merge –no–ff myfeature，是为了避免fast-forward合并对合并的影响，是为了保留已经合并的myfeature记录。</p>
<h2 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h2><p>标签是为了更方便地参考提交而给它标上易懂的名称。<br>Git可以使用2种标签：轻标签和注解标签。打上的标签是固定的，不能像分支那样可以移动位置。</p>
<p>轻标签格式</p>
<ul>
<li>添加名称</li>
</ul>
<p>注解标签格式</p>
<ul>
<li>添加名称</li>
<li>添加注解</li>
<li>添加签名</li>
</ul>
<h2 id="改写提交"><a href="#改写提交" class="headerlink" title="改写提交"></a>改写提交</h2><p>改写提交是指对已经提交的提交记录进行修改或修正。在Git中，这通常用于更正提交信息、合并提交、重新排序提交或重新整理提交历史。</p>
<p>以下是一些常见的改写提交的操作：</p>
<ul>
<li>修改提交信息:你可以使用git commit –amend 命令来修改最新的提交信息。这会打开文本编辑器，允许你修改提交的注释。这在提交信息拼写错误或需要补充信息时很有用。</li>
<li>合并提交： 如果你发现你在之前的几次提交中有类似的修改，你可以使用交互式 rebase（git rebase -i）来合并这些提交，将它们合并成一个更大的提交。</li>
<li>重新排序提交： 使用交互式 rebase，你可以重新排序提交历史，改变提交的顺序。</li>
<li>删除提交： 使用交互式 rebase 或 git reset 命令，你可以删除不需要的提交。但要注意，删除已经被推送到远程仓库的提交可能会引起问题。</li>
<li>拆分提交： 通过交互式 rebase，你可以将一个大的提交拆分成多个较小的提交，从而更好地划分功能或修改。</li>
<li>修改文件内容： 如果你希望修改之前提交中的文件内容，你可以使用 git commit –amend 进行提交，并在其中修改文件内容。但要注意，修改已经被推送到远程仓库的提交可能会影响其他人。</li>
</ul>
<p>常见的改写命令：</p>
<ul>
<li>commit –amend  #修改最近一次的提交注释</li>
<li>revert  #用revert命令来取消提交</li>
<li>reset –hard HEAD~  #向后移动HEAD指针</li>
<li>cherry-pick +哈希值  #从分支当中根据哈希值来融进主支</li>
<li>用rebase -i 汇合提交  #合并两次提交，需要squash</li>
<li>用rebase -i 修改提交  #进行修改提交，需要edit</li>
<li>merge –squash  #把分支合并提交<br>其中reset当中的参数<br>模式名称	HEAD的位置	  索引	 工作树   主要使用场合<br>soft		修改		不修改	不修改   只取消提交<br>mixed		修改		修改	不修改   复原修改过的索引的状态<br>hard		修改		修改	修改     彻底取消最近的提交</li>
</ul>
<h1 id="内容叙述–Learning-Git-Branching-在线游戏（在玩）"><a href="#内容叙述–Learning-Git-Branching-在线游戏（在玩）" class="headerlink" title="内容叙述–Learning Git Branching 在线游戏（在玩）"></a>内容叙述–Learning Git Branching 在线游戏（在玩）</h1><p>游戏有如下的关卡：</p>
<ul>
<li>基础篇3关，</li>
<li>高级篇3关，</li>
<li>移动提交记录2个，</li>
<li>杂项5个，</li>
<li>高级话题3个，</li>
<li>git远程仓库8个</li>
<li>git远程仓库高级操作8个</li>
</ul>
<h2 id="基础篇"><a href="#基础篇" class="headerlink" title="基础篇"></a>基础篇</h2><h3 id="Git-Commit"><a href="#Git-Commit" class="headerlink" title="Git Commit"></a>Git Commit</h3><p>Git 仓库中的提交记录保存的是你的目录下所有文件的快照，就像是把整个目录复制，然后再粘贴一样，但比复制粘贴优雅许多！   </p>
<p>Git 希望提交记录尽可能地轻量，因此在你每次进行提交时，它并不会盲目地复制整个目录。条件允许的情况下，它会将当前版本与仓库中的上一个版本进行对比，并把所有的差异打包到一起作为一个提交记录。    </p>
<h3 id="Git-Branch"><a href="#Git-Branch" class="headerlink" title="Git Branch"></a>Git Branch</h3><p>Git 的分支也非常轻量。它们只是简单地<strong>指向</strong>某个提交纪录 —— 仅此而已。所以许多 Git 爱好者传颂：<br><strong>早建分支！多用分支！</strong><br>这是因为即使创建再多的分支也不会造成储存或内存上的开销，并且按逻辑分解工作到不同的分支要比维护那些特别臃肿的分支简单多了。</p>
<p>注意：在 Git 2.23 版本中，引入了一个名为 git switch 的新命令，最终会取代 git checkout，因为 checkout 作为单个命令有点超载（它承载了很多独立的功能）。 由于现在很多人还无法使用 switch，本次课程仍然使用 checkout 而不是 switch， 但是如果你想尝试一下新命令，我们的应用也是支持的！并且你可以从<a href="https://git-scm.com/docs/git-switch">这里</a>学到更多关于新命令的内容。</p>
<h3 id="Git-Merge"><a href="#Git-Merge" class="headerlink" title="Git Merge"></a>Git Merge</h3><p>太好了! 我们已经知道如何提交以及如何使用分支了。接下来咱们看看如何将两个分支合并到一起。就是说我们新建一个分支，在其上开发某个新功能，开发完成后再合并回主线。</p>
<p>咱们先来看一下第一种方法 —— git merge。在 Git 中合并两个分支时会产生一个特殊的提交记录，它有两个 parent 节点。翻译成自然语言相当于：“我要把这两个 parent 节点本身及它们所有的祖先都包含进来。”</p>
<h3 id="Git-Rebase"><a href="#Git-Rebase" class="headerlink" title="Git Rebase"></a>Git Rebase</h3><p>第二种合并分支的方法是 git rebase。Rebase 实际上就是取出一系列的提交记录，“复制”它们，然后在另外一个地方逐个的放下去。</p>
<p>Rebase 的优势就是可以创造更线性的提交历史，这听上去有些难以理解。如果只允许使用 Rebase 的话，代码库的提交历史将会变得异常清晰。</p>
<h2 id="高级篇"><a href="#高级篇" class="headerlink" title="高级篇"></a>高级篇</h2><h3 id="HEAD"><a href="#HEAD" class="headerlink" title="HEAD"></a>HEAD</h3><p>HEAD 是一个对当前所在分支的符号引用 —— 也就是指向你正在其基础上进行工作的提交记录。</p>
<p>HEAD 总是指向当前分支上最近一次提交记录。大多数修改提交树的 Git 命令都是从改变 HEAD 的指向开始的。</p>
<p>HEAD 通常情况下是指向分支名的（如 bugFix）。在你提交时，改变了 bugFix 的状态，这一变化通过 HEAD 变得可见。</p>
<h3 id="相对引用"><a href="#相对引用" class="headerlink" title="相对引用"></a>相对引用</h3><p>通过指定提交记录哈希值的方式在 Git 中移动不太方便。在实际应用时，并没有像本程序中这么漂亮的可视化提交树供你参考，所以你就不得不用 git log 来查查看提交记录的哈希值。</p>
<p>并且哈希值在真实的 Git 世界中也会更长（译者注：基于 SHA-1，共 40 位）。例如前一关的介绍中的提交记录的哈希值可能是 fed2da64c0efc5293610bdd892f82a58e8cbc5d8。舌头都快打结了吧…</p>
<p>比较令人欣慰的是，Git 对哈希的处理很智能。你只需要提供能够唯一标识提交记录的前几个字符即可。因此我可以仅输入fed2 而不是上面的一长串字符。<br>正如我前面所说，通过哈希值指定提交记录很不方便，所以 Git 引入了相对引用。这个就很厉害了!</p>
<p>使用相对引用的话，你就可以从一个易于记忆的地方（比如 bugFix 分支或 HEAD）开始计算。</p>
<p>相对引用非常给力，这里我介绍两个简单的用法：</p>
<p>使用 ^ 向上移动 1 个提交记录<br>使用 ~&lt; num &gt; 向上移动多个提交记录，如 ~3</p>
<p>“~”操作符<br>如果你想在提交树中向上移动很多步的话，敲那么多 ^ 貌似也挺烦人的，Git 当然也考虑到了这一点，于是又引入了操作符 ~。</p>
<p>该操作符后面可以跟一个数字（可选，不跟数字时与 ^ 相同，向上移动一次），指定向上移动多少次。咱们还是通过实际操作看一下吧</p>
<h3 id="撤销变更"><a href="#撤销变更" class="headerlink" title="撤销变更"></a>撤销变更</h3><p>在 Git 里撤销变更的方法很多。和提交一样，撤销变更由底层部分（暂存区的独立文件或者片段）和上层部分（变更到底是通过哪种方式被撤销的）组成。我们这个应用主要关注的是后者。</p>
<p>主要有两种方法用来撤销变更 —— 一是 git reset，还有就是 git revert。接下来咱们逐个进行讲解。</p>
<p>git reset 通过把分支记录回退几个提交记录来实现撤销改动。你可以将这想象成“改写历史”。git reset 向上移动分支，原来指向的提交记录就跟从来没有提交过一样。</p>
<p>虽然在你的本地分支中使用 git reset 很方便，但是这种“改写历史”的方法对大家一起使用的远程分支是无效的哦！</p>
<p>为了撤销更改并分享给别人，我们需要使用 git revert。</p>
<h2 id="移动提交记录"><a href="#移动提交记录" class="headerlink" title="移动提交记录"></a>移动提交记录</h2><h3 id="Git-Cherry-pick"><a href="#Git-Cherry-pick" class="headerlink" title="Git Cherry-pick"></a>Git Cherry-pick</h3><p>本系列的第一个命令是 git cherry-pick, 命令形式为:</p>
<p>git cherry-pick &lt;提交号&gt;…<br>如果你想将一些提交复制到当前所在的位置（HEAD）下面的话， Cherry-pick 是最直接的方式了。我个人非常喜欢 cherry-pick，因为它特别简单。</p>
<h3 id="交互式的-rebase"><a href="#交互式的-rebase" class="headerlink" title="交互式的 rebase"></a>交互式的 rebase</h3><p>当你知道你所需要的提交记录（并且还知道这些提交记录的哈希值）时, 用 cherry-pick 再好不过了 —— 没有比这更简单的方式了。</p>
<p>但是如果你不清楚你想要的提交记录的哈希值呢? 幸好 Git 帮你想到了这一点, 我们可以利用交互式的 rebase —— 如果你想从一系列的提交记录中找到想要的记录, 这就是最好的方法了</p>
<p>交互式 rebase 指的是使用带参数 –interactive 的 rebase 命令, 简写为 -i</p>
<p>如果你在命令后增加了这个选项, Git 会打开一个 UI 界面并列出将要被复制到目标分支的备选提交记录，它还会显示每个提交记录的哈希值和提交说明，提交说明有助于你理解这个提交进行了哪些更改。</p>
<h2 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h2><h3 id="本地栈式提交"><a href="#本地栈式提交" class="headerlink" title="本地栈式提交"></a>本地栈式提交</h3><p>来看一个在开发中经常会遇到的情况：我正在解决某个特别棘手的 Bug，为了便于调试而在代码中添加了一些调试命令并向控制台打印了一些信息。</p>
<p>这些调试和打印语句都在它们各自的提交记录里。最后我终于找到了造成这个 Bug 的根本原因，解决掉以后觉得沾沾自喜！</p>
<p>最后就差把 bugFix 分支里的工作合并回 main 分支了。你可以选择通过 fast-forward 快速合并到 main 分支上，但这样的话 main 分支就会包含我这些调试语句了。你肯定不想这样，应该还有更好的方式……</p>
<p>实际我们只要让 Git 复制解决问题的那一个提交记录就可以了。跟之前我们在“整理提交记录”中学到的一样，我们可以使用</p>
<p>git rebase -i<br>git cherry-pick<br>来达到目的。</p>
<h3 id="提交的技巧-1"><a href="#提交的技巧-1" class="headerlink" title="提交的技巧 #1"></a>提交的技巧 #1</h3><h2 id="高级话题"><a href="#高级话题" class="headerlink" title="高级话题"></a>高级话题</h2><h2 id="git远程仓库"><a href="#git远程仓库" class="headerlink" title="git远程仓库"></a>git远程仓库</h2><h2 id="git远程仓库高级操作"><a href="#git远程仓库高级操作" class="headerlink" title="git远程仓库高级操作"></a>git远程仓库高级操作</h2>]]></content>
      <categories>
        <category>编程学习笔记</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>算法导论阅读笔记</title>
    <url>/2023/08/27/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>大一的时候买的书，一直说以后看，以后看，这一推就到了现在，不能再推下去了。<br>现在开始啃这本书，可以说我是抱着巨大的勇气进行的，特别决定了还要发到博客当中去监督自己的这一决心。<br>所以这个系列在表述的过程当中可能会有误，希望有大佬看到错误的地方可以私发我邮件，或则评论区指出，无论有多尖锐都请您随意发出，不用客气的批评我，这里再次表达感激之情。<br>现在让我开始啃这个巨著吧，争取做到日更。</p>
<h1 id="第一部分-基础知识"><a href="#第一部分-基础知识" class="headerlink" title="第一部分 基础知识"></a>第一部分 基础知识</h1><h2 id="第1章-算法在计算中的作用"><a href="#第1章-算法在计算中的作用" class="headerlink" title="第1章 算法在计算中的作用"></a>第1章 算法在计算中的作用</h2><h3 id="1-1-算法"><a href="#1-1-算法" class="headerlink" title="1.1 算法"></a>1.1 算法</h3><p>算法就是任何良定义的计算过程，也可以看作是用于求解良说明的计算问题的工具。<br>良定义包含四个方面：明确性，有限性，输入和输出，可行性。<br>良说明包含五个方面：输入， 输出，约束条件，问题的性质，示例。</p>
<p>许多有趣算法问题所共有的两个特征：<br>1.存在许多候选解<br>2.存在实际应用<br>候选解指的是：候选解是指在解决问题或完成任务时，被认为可能是正确或有效解决方案的一个潜在选择。</p>
<p>NP完全的问题需要满足两个条件：<br>1.可证明性<br>2.NP难度</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">举例子：想象你在玩一个拼图游戏，你得到了一些拼图块，而且你需要将它们组合成一个完整的拼图。如果你把所有的拼图块正确地组合在一起，你可以很容易地看到结果是正确的。这就是“可证明性”，因为你可以验证最终拼图是否正确。    </span><br><span class="line">现在，假设你没有完整的拼图图像，而是零散地得到一块块拼图，然后需要找到一个方法将它们组合起来。NP-完全问题就类似于这种情况。它们要求你找到一个解，就像是将零散的拼图块组合在一起，以满足某些条件。这些问题很难，因为找到这种解看起来并不容易。   </span><br><span class="line">但是，如果你告诉别人你已经找到了一个可能的拼图组合方式，别人可以很快地验证它是否正确。这就是问题的“可证明性”。NP-完全问题的关键在于，如果你能够在快速的时间内验证一个可能的解，那么理论上你也可以在快速的时间内找到一个解。这就是为什么这些问题被认为是非常困难的，因为目前我们没有找到一种快速的方法来解决它们，但如果我们找到了一个解，我们可以快速地验证它是否正确。</span><br></pre></td></tr></table></figure>

<p>练习:<br>1.1-1     </p>
<h3 id="1-2-作为一种技术的算法"><a href="#1-2-作为一种技术的算法" class="headerlink" title="1.2 作为一种技术的算法"></a>1.2 作为一种技术的算法</h3>]]></content>
      <categories>
        <category>编程学习笔记</category>
      </categories>
      <tags>
        <tag>算法导论</tag>
        <tag>阅读笔记</tag>
      </tags>
  </entry>
</search>
